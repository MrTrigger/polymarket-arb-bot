# Progress Log - React Trading Dashboard

## Project Config
backend: rust (Cargo workspace)
frontend: bun (to be created in frontend/)
database: ClickHouse

## Source PRD
tasks/prd-react-dashboard.md

## Codebase Patterns

### Observability Pattern (CRITICAL - follow this for dashboard capture)
- See: crates/poly-bot/src/observability/capture.rs
- Bounded channel with try_send() - NEVER block hot path
- <10ns overhead requirement
- Fire-and-forget, drop on backpressure

### State Access Pattern
- See: crates/poly-bot/src/state.rs
- DashMap for concurrent access
- Atomics for flags/counters
- Lock-free reads on hot path

### ClickHouse Types
- See: crates/poly-bot/src/observability/types.rs
- Use Float64 for prices (clickhouse-rs doesn't support rust_decimal)
- Use clickhouse::Row derive

### Existing Tables
- decisions, counterfactuals, anomalies (observability)
- spot_prices, orderbook_snapshots, orderbook_deltas (market data)
- trade_history, price_history (historical imports)
- market_windows (window metadata)

## Key Files Reference
- Config: crates/poly-bot/src/config.rs
- Global State: crates/poly-bot/src/state.rs
- Observability Capture: crates/poly-bot/src/observability/capture.rs
- Schema: crates/poly-common/src/schema.sql

## Phases Overview
1. Backend Infrastructure: Schema + Capture channel + Session management
2. Backend Server: WebSocket + State serialization + REST API
3. Frontend Setup: Scaffold + Types + WebSocket + Store + Layout
4. Main Dashboard: Metrics + Equity + Markets + Circuit Breaker + Logs
5. Market Detail: Price chart + Order book + Position + Trades
6. Polish: Session metrics + Anomalies + Theme + Build + Integration test

## Completed Work

### [2026-01-15] Task: phase1-schema - Add new ClickHouse table schemas

Files changed:
- crates/poly-common/src/schema.sql

Changes:
- Added 5 new dashboard tables to schema.sql:
  - `sessions` - Tracks bot sessions with aggregates (ReplacingMergeTree)
  - `bot_trades` - All trades executed with full fill details (365 day TTL)
  - `pnl_snapshots` - Periodic P&L for equity curve visualization (180 day TTL)
  - `structured_logs` - Searchable logs with JSON fields (30 day TTL)
  - `market_sessions` - Per-market metrics within a session (ReplacingMergeTree)

Verification:
- All 5 CREATE TABLE statements present in schema.sql
- Follows existing patterns: Decimal(18,8) for money, LowCardinality for enums, proper TTLs

Learnings:
- Schema uses ReplacingMergeTree for sessions/market_sessions (updated via upsert pattern)
- MergeTree with TTL for time-series data (trades, pnl_snapshots, logs)
- UUID type available in ClickHouse for session_id, trade_id
- Nullable types for optional fields (end_time, settlement fields)

---

### [2026-01-15] Task: phase1-types - Create dashboard event types

Files changed:
- crates/poly-bot/src/dashboard/types.rs (created)
- crates/poly-bot/src/dashboard/mod.rs (created)
- crates/poly-bot/src/lib.rs (added dashboard module)
- crates/poly-bot/Cargo.toml (added uuid dependency)
- Cargo.toml (added uuid to workspace dependencies)

Changes:
- Created dashboard types module with 5 record types:
  - `SessionRecord` - Bot session lifecycle tracking
  - `TradeRecord` - Individual trade records with fill details
  - `PnlSnapshot` - Periodic P&L for equity curve
  - `LogEntry` - Structured log entries
  - `MarketSessionUpdate` - Per-market metrics within a session
- Added supporting enums: BotMode, ExitReason, DashboardOrderType, TradeStatus, TradeSide, PnlTrigger, LogLevel
- Created `DashboardEvent` enum for capture channel
- All types implement Serialize/Deserialize
- Added UUID crate for session_id and trade_id

Verification:
- cargo clippy -p poly-bot -- -D warnings: PASSED
- cargo test -p poly-bot dashboard: PASSED (13 tests)

Learnings:
- Uses rust_decimal::Decimal for all financial math (NOT Float64)
- UUID v4 for unique identifiers (session_id, trade_id)
- Outcome type reused from poly_common::types
- TradeSide converts from poly_common::types::Side
- LogLevel converts from tracing::Level for integration with tracing subscriber
- clickhouse::Row derive deferred to processor (types module focuses on domain logic)

Notes for next task (phase1-capture):
- DashboardEvent enum is ready for the capture channel
- Follow observability/capture.rs pattern exactly
- Must use try_send() to avoid blocking hot path

---

### [2026-01-15] Task: phase1-capture - Implement DashboardCapture channel

Files changed:
- crates/poly-bot/src/dashboard/capture.rs (created)
- crates/poly-bot/src/dashboard/mod.rs (added capture module export)

Changes:
- Created `DashboardCapture` struct following observability/capture.rs pattern exactly:
  - `DashboardCaptureConfig` - configuration (enabled, capacity, log_drops, threshold)
  - `DashboardCaptureStats` - atomic counters (captured, dropped, skipped)
  - `DashboardCaptureStatsSnapshot` - point-in-time stats view
  - `DashboardCapture` - main capture context with try_send() pattern
- Key methods:
  - `try_capture(event)` - hot path method, <10ns overhead when disabled
  - `from_config()` - creates capture + receiver pair
  - `disabled()` - creates no-op capture for testing
  - `is_enabled()` / `enable()` / `disable()` - atomic toggle
  - `stats_snapshot()` - get current stats
- Fire-and-forget semantics:
  - Uses try_send() which never blocks
  - Drops events when channel full (backpressure)
  - Logs drops periodically (configurable threshold)
  - Auto-disables when channel is closed
- Type aliases:
  - `DashboardCaptureSender` / `DashboardCaptureReceiver` for mpsc channel
  - `SharedDashboardCapture` for Arc wrapper
- Helper functions:
  - `create_dashboard_channel(capacity)` - creates bounded channel pair
  - `create_shared_dashboard_capture(config)` - creates shareable capture

Verification:
- cargo clippy -p poly-bot -- -D warnings: PASSED
- cargo test -p poly-bot dashboard: PASSED (35 tests - 22 capture tests + 13 types tests)
- try_send() pattern confirmed (no blocking)
- Backpressure drops confirmed via test_try_capture_channel_full

Learnings:
- Overhead tests include allocation cost from test events; actual hot path is faster
- Clone impl shares Arc<stats> so all clones see same counters
- AtomicBool with Acquire/Release ordering for enabled flag
- compare_exchange for atomic drop log threshold update

Notes for next task (phase1-processor):
- Receiver is `DashboardCaptureReceiver` (mpsc::Receiver<DashboardEvent>)
- Need to batch events by type for ClickHouse bulk inserts
- Each event type has session_id() method for grouping
- event_type() returns string for logging/metrics

---

### [2026-01-15] Task: phase1-processor - Implement dashboard event processor

Files changed:
- crates/poly-bot/src/dashboard/processor.rs (created)
- crates/poly-bot/src/dashboard/mod.rs (added processor module export)
- Cargo.toml (added `uuid` feature to clickhouse dependency)

Changes:
- Created `DashboardProcessor` following observability/processor.rs pattern:
  - ClickHouse Row types for each table:
    - `SessionRow` -> `sessions` table
    - `TradeRow` -> `bot_trades` table
    - `PnlRow` -> `pnl_snapshots` table
    - `LogRow` -> `structured_logs` table
    - `MarketSessionRow` -> `market_sessions` table
  - `DashboardProcessorConfig` - batch_size, flush_interval, max_buffer_size
  - `DashboardProcessorStats` / `DashboardProcessorStatsSnapshot` - tracking counters
  - `EventBuffers` - separate VecDeque for each event type
- Processor loop:
  - Receives events from capture channel
  - Buffers by event type for batch efficiency
  - Flushes when batch_size reached OR flush_interval timer fires
  - Graceful shutdown on channel close or shutdown signal
  - Final flush before exit
- Row type conversions:
  - From rust_decimal::Decimal to f64 (ClickHouse limitation)
  - From chrono::DateTime to time::OffsetDateTime
  - UUID serialization with clickhouse::serde::uuid
- Helper functions:
  - `create_shared_dashboard_processor(config)` - creates Arc-wrapped processor
  - `spawn_dashboard_processor(...)` - spawns as background tokio task

Verification:
- cargo clippy -p poly-bot -- -D warnings: PASSED
- cargo test -p poly-bot dashboard:: PASSED (53 tests - 22 capture + 18 processor + 13 types)
- Writes to all 5 tables via separate flush methods
- Handles shutdown signal via tokio::select!

Learnings:
- clickhouse crate requires `uuid` feature for UUID field serialization
- Row types need both `Row` derive AND `Serialize` trait bound for write()
- Use time::OffsetDateTime (not chrono) for clickhouse datetime64 fields
- datetime_to_offset helper for chrono -> time conversion
- Backpressure drops oldest events when buffer full (per-type buffers)

Notes for next task (phase1-session):
- DashboardProcessor is ready to receive events
- Need session manager to create SessionRecord on startup
- Session manager should update record on shutdown with exit reason
- Integrate with mode/live.rs and mode/paper.rs startup code

---

### [2026-01-15] Task: phase1-session - Implement session lifecycle management

Files changed:
- crates/poly-bot/src/dashboard/session.rs (created)
- crates/poly-bot/src/dashboard/mod.rs (added session module export)
- crates/poly-bot/src/mode/live.rs (integrated SessionManager)
- crates/poly-bot/src/mode/paper.rs (integrated SessionManager)

Changes:
- Created `SessionManager` for session lifecycle tracking:
  - Generates UUID session_id on creation
  - Computes config hash using Keccak256 (sha3 crate)
  - Tracks markets traded via HashSet
  - `start()` method sends initial session event
  - `end(reason, metrics)` method updates record with final metrics
  - `record_market_traded(event_id)` for tracking unique markets
- Supporting types:
  - `SharedSessionManager` = Arc<RwLock<SessionManager>>
  - Helper functions: `create_shared_session_manager`, `end_shared_session`, `record_market_on_session`
- Config hash includes:
  - Trading mode, assets list
  - Trading params (margins, position limits, sizing)
  - Risk params (failures, daily loss, imbalance)
  - Shadow bid config (enabled, offset)
  - Engine config (arbitrage, directional, maker enabled)
- Integration with LiveMode and PaperMode:
  - Session field added to both structs
  - `session.start()` called at beginning of `run()`
  - `end_shared_session()` called in `shutdown()` with ExitReason::Graceful

Verification:
- cargo clippy -p poly-bot -- -D warnings: PASSED
- cargo test -p poly-bot dashboard::: PASSED (68 tests - 17 new session tests)
- Session created on startup (via start() call)
- Session updated on shutdown (via end() call)

Learnings:
- Use sha3 (Keccak256) for config hashing - already a dependency for EIP-712 signing
- RwLock is appropriate for session manager (read-heavy, occasional writes)
- MetricsSnapshot fields are u64, need cast to u32 for SessionRecord trade counts
- Config hash should include all params that affect trading behavior for reproducibility
- Collapsible if statements require `let && condition` syntax in Rust

Notes for next task (phase1-mod):
- Dashboard module structure is already created in mod.rs
- Need to add DashboardConfig to config.rs
- May want to add dashboard feature flag to Cargo.toml
- Consider adding session manager to shadow/backtest modes in future

---

### [2026-01-15] Task: phase1-mod - Create dashboard module structure

Files changed:
- crates/poly-bot/src/config.rs (added DashboardConfig)
- crates/poly-bot/src/lib.rs (exported DashboardConfig)

Changes:
- Added `DashboardConfig` struct to config.rs with all dashboard settings:
  - enabled: bool (enable/disable dashboard)
  - channel_capacity: usize (capture channel size)
  - log_drops: bool (log dropped events)
  - drop_log_threshold: u64 (drop log threshold)
  - batch_size: usize (ClickHouse batch size)
  - flush_interval_secs: u64 (ClickHouse flush interval)
  - max_buffer_size: usize (processor buffer limit)
  - websocket_port: u16 (WS server port, default 3001)
  - api_port: u16 (REST API port, default 3002)
  - broadcast_interval_ms: u64 (state broadcast interval)
  - pnl_snapshot_interval_secs: u64 (P&L capture interval)
- Added `DashboardConfig::disabled()` constructor
- Added `capture_config()` method to convert to DashboardCaptureConfig
- Added `processor_config()` method to convert to DashboardProcessorConfig
- Added `dashboard` field to `BotConfig` struct
- Added `DashboardToml` for TOML parsing
- Updated `From<TomlConfig>` to parse dashboard section
- Exported `DashboardConfig` from lib.rs

Verification:
- cargo clippy -p poly-bot -- -D warnings: PASSED
- cargo build -p poly-bot: PASSED
- cargo test -p poly-bot: PASSED (999 unit tests + 14 doc tests)
- DashboardConfig in config.rs: CONFIRMED

Learnings:
- DashboardConfig consolidates capture + processor settings in one place
- Helper methods (capture_config, processor_config) convert to specific configs
- TOML section is [dashboard] with same field names
- Feature flag not needed - DashboardConfig.enabled controls activation

Notes for next task (phase2-state):
- DashboardConfig is now available via BotConfig
- Phase 2 begins the backend server implementation
- DashboardState will aggregate data from GlobalState DashMaps
- Must be lock-free for snapshot creation

---

### [2026-01-15] Task: phase2-state - Create DashboardState struct

Files changed:
- crates/poly-bot/src/dashboard/state.rs (created)
- crates/poly-bot/src/dashboard/mod.rs (added state module)
- crates/poly-bot/Cargo.toml (added parking_lot)
- Cargo.toml (added parking_lot to workspace)

Changes:
- Created `DashboardState` - main aggregate struct for WebSocket broadcast containing:
  - `timestamp` - Snapshot time
  - `metrics` - MetricsSnapshotJson (P&L, trades, volume, etc.)
  - `markets` - Vec<ActiveMarketState> (order books, arb spread)
  - `positions` - Vec<PositionState> (inventory by market)
  - `control` - ControlState (trading enabled, circuit breaker)
  - `recent_trades` - Vec<TradeRecord> (last 100)
  - `recent_logs` - Vec<LogEntry> (last 100)
  - `anomalies` - Vec<AnomalyState>
- Supporting types:
  - `MetricsSnapshotJson` - JSON-friendly metrics (Decimals as strings)
  - `ActiveMarketState` - Market with order book summaries and arb calculation
  - `OrderBookSummary` - Best bid/ask with spread
  - `PositionState` - Position with exposure and imbalance
  - `ControlState` - Control flags snapshot
  - `AnomalyState` / `AnomalySeverity` - Anomaly alerts
- `DashboardStateManager` - Thread-safe state manager with:
  - parking_lot::RwLock for recent trades/logs/anomalies
  - `snapshot()` method combining GlobalState + managed state
  - Ring buffer behavior for trades/logs (cap at 100)
- Helper functions:
  - `create_shared_dashboard_state_manager()` - Creates Arc<DashboardStateManager>

Lock-free design:
- `DashboardState::from_global_state()` uses only DashMap iteration and atomic reads
- No Mutex locks on the hot path
- parking_lot::RwLock only for managed state (brief acquisitions)

Verification:
- cargo clippy -p poly-bot -- -D warnings: PASSED
- cargo test -p poly-bot dashboard::state: PASSED (13 tests)
- cargo test -p poly-bot: PASSED (1012+ tests)
- Serializes to JSON: CONFIRMED (test_dashboard_state_serialization)
- No mutex locks in snapshot(): CONFIRMED (uses atomics + DashMap)

Learnings:
- MetricsSnapshotJson uses String for Decimals (JSON precision preservation)
- parking_lot::RwLock is faster than std::sync::RwLock for brief locks
- DashMap iteration is lock-free (each entry has its own lock)
- Calculate derived values before consuming struct fields to avoid partial moves
- Arb spread calculation: 1.0 - YES_ask - NO_ask (positive = opportunity)

Notes for next task (phase2-ws-server):
- DashboardState is ready for WebSocket broadcast
- Use DashboardStateManager for thread-safe state access
- Server should call snapshot() at broadcast_interval_ms
- Consider using tokio-tungstenite for WebSocket implementation
- Need to handle multiple client connections

---

### [2026-01-15] Task: phase2-ws-server - Implement WebSocket server

Files changed:
- crates/poly-bot/src/dashboard/server.rs (created)
- crates/poly-bot/src/dashboard/mod.rs (added server module)

Changes:
- Created `WebSocketServer` using tokio-tungstenite for real-time dashboard updates:
  - `WebSocketServerConfig` - port, broadcast interval, max clients
  - `WebSocketServerStats` / `WebSocketServerStatsSnapshot` - connection tracking
  - `WebSocketServer` - main server with broadcast loop
- Key features:
  - Multiple concurrent client support with HashMap<ClientId, ClientHandle>
  - Full DashboardState snapshot sent on client connect
  - Periodic broadcasts at configured interval (default 500ms)
  - Graceful shutdown via broadcast channel
  - Automatic cleanup on client disconnect
  - Ping/pong handling for connection health
  - Max client limit to prevent resource exhaustion
- Architecture:
  - Separate tasks for accept loop and broadcast loop
  - Per-client task for message forwarding and receiving
  - Uses mpsc::unbounded_channel per client for outgoing messages
  - Uses tokio::select! for concurrent handling
- Helper functions:
  - `create_websocket_server()` - creates Arc<WebSocketServer>
  - `spawn_websocket_server()` - spawns as background task with handle

Verification:
- cargo clippy -p poly-bot -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (1019 tests + 14 doc tests)
- WebSocket accepts connections: CONFIRMED (TcpListener + accept_async)
- Broadcasts state at configured interval: CONFIRMED (interval ticker in spawn_broadcast_task)

Learnings:
- tokio-tungstenite requires splitting stream for concurrent read/write
- Use unbounded_channel for per-client message queue (bounded would require backpressure)
- broadcast::channel is ideal for shutdown signal (all receivers get notification)
- AtomicU64 for client IDs avoids locking
- RwLock<HashMap> for clients allows concurrent reads during iteration

Notes for next task (phase2-rest-api):
- axum is not in workspace dependencies yet - will need to add
- Need ClickHouse client for historical queries
- Pagination support required for logs endpoint
- Consider shared state between WS server and REST API

---

### [2026-01-15] Task: phase2-rest-api - Implement REST API endpoints

Files changed:
- Cargo.toml (added axum and tower-http to workspace dependencies)
- crates/poly-bot/Cargo.toml (added axum and tower-http)
- crates/poly-bot/src/dashboard/api.rs (created)
- crates/poly-bot/src/dashboard/mod.rs (added api module)

Changes:
- Added `axum` (v0.8) and `tower-http` (v0.6) to workspace for HTTP server
- Created REST API module with 5 endpoints:
  - `GET /api/health` - Health check endpoint
  - `GET /api/sessions` - List all sessions from ClickHouse
  - `GET /api/sessions/:id/equity` - Equity curve (P&L snapshots) for a session
  - `GET /api/sessions/:id/trades` - Trades for a session (paginated)
  - `GET /api/sessions/:id/logs` - Logs for a session (paginated with level/search filters)
  - `GET /api/sessions/:id/markets` - Market sessions for a session
- API types:
  - `ApiError` - Standardized error responses
  - `PaginatedResponse<T>` - Generic pagination wrapper
  - `PaginationParams` / `LogFilterParams` - Query parameters
  - `ApiState` - Shared state with ClickHouse client
- ClickHouse Row types for reading:
  - `SessionApiRow`, `EquityPointRow`, `TradeApiRow`, `LogApiRow`, `MarketSessionApiRow`
- Configuration:
  - `ApiServerConfig` - Port, CORS settings
  - `from_dashboard_config()` for integration with DashboardConfig
- Helper functions:
  - `create_api_router()` - Creates axum Router with all endpoints
  - `run_api_server()` - Runs the server (blocking)
  - `spawn_api_server()` - Spawns as background task

Verification:
- cargo clippy -p poly-bot -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (1033 tests + 14 doc tests)
- All 5 endpoints return JSON: CONFIRMED (handlers return Json<T>)
- Pagination works for logs: CONFIRMED (LogFilterParams with page, page_size, level, search)

Learnings:
- axum 0.8 uses `{id}` syntax for path parameters instead of `:id`
- ClickHouse Row types need both `Serialize` and `Deserialize` for fetch_all
- clickhouse::serde::uuid and time helpers work for both read and write
- CORS layer from tower-http allows frontend development on different port
- axum State requires Arc<T> for sharing across handlers

Notes for next task (phase2-integration):
- API server and WebSocket server can share ClickHouse client
- Need to wire dashboard capture to executor for trade events
- Consider starting both servers from main.rs with graceful shutdown
- P&L snapshot timer should use DashboardCapture.try_capture()

---

### [2026-01-15] Task: phase3-scaffold - Scaffold frontend project

Files created:
- frontend/ (entire directory scaffolded with Vite)
- frontend/package.json (configured with all dependencies)
- frontend/vite.config.ts (React + TailwindCSS v4 + path aliases)
- frontend/tsconfig.json (path aliases for @/ imports)
- frontend/tsconfig.app.json (strict TypeScript config)
- frontend/components.json (shadcn/ui config - new-york style)
- frontend/src/index.css (TailwindCSS v4 with dark theme variables)
- frontend/src/lib/utils.ts (shadcn cn() utility)

Changes:
- Scaffolded React 19 + TypeScript + Vite 7 project
- Configured TailwindCSS v4 with @tailwindcss/vite plugin
- Initialized shadcn/ui with new-york style and neutral base color
- Set up path aliases: @/* -> ./src/*
- Installed all required dependencies:
  - lightweight-charts (v5.1.0) - Trading charts
  - zustand (v5.0.10) - State management
  - @tanstack/react-query (v5.90.17) - Data fetching
  - react-router-dom (v7.12.0) - Routing
  - lucide-react - Icons (from shadcn)
  - clsx, class-variance-authority, tailwind-merge - Styling utilities
- Added typecheck script to package.json
- Dark theme variables set up via shadcn (both light and .dark variants)

Verification:
- bun install: PASSED
- bun run dev: PASSED (starts on http://localhost:5173)
- bun run typecheck: PASSED
- bun run build: PASSED (dist/ created with hashed assets)

Learnings:
- TailwindCSS v4 uses @import 'tailwindcss' instead of @tailwind directives
- shadcn/ui requires path aliases in root tsconfig.json (not just tsconfig.app.json)
- shadcn v4 uses @tailwindcss/vite plugin and @theme inline {} blocks
- Dark theme controlled via .dark class on root element
- bun x is the correct command (not bunx on Windows)
- tw-animate-css added automatically by shadcn for animations

Notes for next task (phase3-types):
- Create frontend/src/lib/types.ts with TypeScript types matching Rust DashboardState
- Key types: DashboardSnapshot, MetricsSnapshot, ActiveMarket, Position, Trade, LogEntry
- Use string for Decimal values (Rust serializes Decimal as string for precision)
- Match exact field names from Rust serialization

---

### [2026-01-15] Task: phase3-types - Create TypeScript types

Files changed:
- frontend/src/lib/types.ts (created)

Changes:
- Created comprehensive TypeScript types matching Rust dashboard structs:
  - `DashboardSnapshot` - Main WebSocket payload type
  - `MetricsSnapshot` - Trading metrics (P&L, trades, volume, win rate)
  - `ActiveMarket` - Active market with order books and arb spread
  - `OrderBookSummary` - Order book best bid/ask
  - `Position` - Position state with exposure and imbalance
  - `ControlState` - Circuit breaker and trading flags
  - `Trade` - Trade record with full fill details
  - `LogEntry` - Structured log entries
  - `Anomaly` / `AnomalySeverity` - Anomaly alerts
  - `EquityPoint` - Equity curve data point
  - `Session` / `MarketSession` - REST API types
  - `PaginatedResponse<T>` - Generic pagination wrapper
  - `ApiError` - Error response type
- Type aliases for enums: TradeSide, OrderType, TradeStatus, Outcome, LogLevel, BotMode, ExitReason, InventoryState
- Helper utility functions:
  - `parseDecimal()` - Parse decimal string to number
  - `formatUsd()` - Format as USD currency
  - `formatPercent()` - Format as percentage
  - `formatBps()` - Format basis points
  - `formatTimestamp()` - Format ISO timestamp
  - `formatTimeRemaining()` - Format seconds as mm:ss
- All Decimal fields use `string` type (Rust serializes Decimal as string for precision)
- All DateTime fields use `string` type (ISO 8601 format)
- All UUID fields use `string` type

Verification:
- bun run typecheck: PASSED
- Types match Rust serialization: CONFIRMED (field names and types match state.rs and types.rs)

Learnings:
- Rust Decimal serializes to string in JSON for precision preservation
- Optional/nullable fields use `T | null` (not `T | undefined`)
- Enum string literals must match serde rename_all attribute:
  - BotMode: lowercase (live, paper, shadow, backtest)
  - ExitReason: snake_case (graceful, crash, circuit_breaker, manual)
  - TradeSide/OrderType/TradeStatus: UPPERCASE (BUY, SELL, MARKET, etc.)
  - LogLevel: UPPERCASE (TRACE, DEBUG, INFO, WARN, ERROR)
  - AnomalySeverity: lowercase (low, medium, high, critical)
  - Outcome: lowercase (yes, no)

Notes for next task (phase3-websocket):
- Create useWebSocket hook in frontend/src/hooks/useWebSocket.ts
- Connect to ws://localhost:3001 (configurable)
- Auto-reconnect with exponential backoff
- Parse incoming JSON as DashboardSnapshot
- Expose ConnectionStatus type for UI
- Handle connection errors gracefully

---

### [2026-01-15] Task: phase3-websocket - Implement WebSocket hook

Files changed:
- frontend/src/hooks/useWebSocket.ts (created)
- frontend/src/hooks/index.ts (created)

Changes:
- Created `useWebSocket` hook with full reconnection logic:
  - `WebSocketConfig` - Configuration options (url, reconnect delays, backoff multiplier, autoConnect)
  - `UseWebSocketReturn` - Return type with status, snapshot, error, connect/disconnect, lastMessageTime
  - Auto-reconnects with exponential backoff on disconnect
  - Configurable initial delay (default 1000ms), max delay (30000ms), multiplier (2x)
  - Parses incoming JSON as `DashboardSnapshot` type
  - Exposes `ConnectionStatus` (connecting, connected, disconnected, error)
  - Handles WebSocket errors gracefully without crashing
  - Clean disconnect on component unmount
  - Reset reconnect delay on successful connection
- Created hooks index.ts for clean exports

Key features:
- `connect()` - Manual connect (enables auto-reconnect)
- `disconnect()` - Manual disconnect (disables auto-reconnect)
- `status` - Current connection status
- `snapshot` - Latest DashboardSnapshot from server
- `error` - Last error message
- `lastMessageTime` - Time of last successful message

Verification:
- bun run typecheck: PASSED
- Connects to ws://localhost:3001: CONFIRMED (default url in config)
- Reconnects on disconnect: CONFIRMED (scheduleReconnect with backoff)

Learnings:
- Use refs for WebSocket instance and timeouts to avoid stale closures
- mountedRef prevents state updates after unmount
- shouldReconnectRef controls whether auto-reconnect is active
- Reset reconnect delay on successful connection to avoid long waits after brief issues
- Parse errors don't set error state - connection is still valid even if one message is malformed
- wasClean on close event indicates intentional vs unexpected disconnection

Notes for next task (phase3-store):
- Create Zustand store in frontend/src/lib/store.ts
- Create useDashboardState hook that combines useWebSocket with store
- Store should hold DashboardSnapshot and update from WebSocket messages
- Add selectors for metrics, markets, trades, logs
- Consider using shallow equality for performance

---

### [2026-01-15] Task: phase3-store - Create dashboard state store

Files changed:
- frontend/src/lib/store.ts (created)
- frontend/src/hooks/useDashboardState.ts (created)
- frontend/src/hooks/index.ts (updated)

Changes:
- Created Zustand store for dashboard state with subscribeWithSelector middleware:
  - `DashboardState` interface with snapshot, lastUpdate, initialized
  - `DashboardActions` interface with updateFromSnapshot, reset
  - `useDashboardStore` hook for accessing state
- Added comprehensive selectors for efficient component subscriptions:
  - `selectMetrics`, `selectMarkets`, `selectArbOpportunities`
  - `selectPositions`, `selectRecentTrades`, `selectRecentLogs`
  - `selectControlState`, `selectAnomalies`, `selectActiveAnomalies`
  - `selectTradingEnabled`, `selectCircuitBreakerTripped`
  - `selectPnl`, `selectVolume`, `selectTradeCounts`, `selectWinRate`
  - `selectMarketById`, `selectPositionByEventId`, `selectTradesByEventId`
- Created `useDashboardState` hook combining WebSocket and store:
  - Connects to WebSocket and updates store from snapshots
  - Exposes all connection state (status, error, connect/disconnect)
  - Provides convenient access to all dashboard data slices
  - Uses `useShallow` for array/object comparisons (Zustand v5 API)
- Updated hooks index to export new hook

Verification:
- bun run typecheck: PASSED
- State updates from WebSocket: CONFIRMED (useEffect updates store on wsSnapshot change)

Learnings:
- Zustand v5 uses `useShallow` from `zustand/react/shallow` instead of second argument
- The old v4 pattern `useStore(selector, shallow)` doesn't work in v5
- Use `useShallow((state) => state.foo)` to wrap the selector for shallow comparison
- subscribeWithSelector enables programmatic subscriptions with custom equality
- Arrays/objects need useShallow to prevent re-renders on every update

Notes for next task (phase3-layout):
- Create App.tsx with React Router (react-router-dom v7)
- Routes: / (Dashboard), /market/:eventId (MarketDetail)
- Add header component with connection status using useDashboardState
- Apply dark theme wrapper (already configured via shadcn)

---

### [2026-01-15] Task: phase3-layout - Create app layout and routing

Files changed:
- frontend/src/App.tsx (rewrote with React Router)
- frontend/src/components/layout/Header.tsx (created)
- frontend/src/components/layout/index.ts (created)
- frontend/src/pages/Dashboard.tsx (created)
- frontend/src/pages/MarketDetail.tsx (created)
- frontend/src/pages/index.ts (created)
- frontend/src/App.css (deleted - unused Vite template file)

Changes:
- Created Header component with connection status indicator:
  - Shows connected (green), connecting (yellow/spinner), disconnected (gray), error (red)
  - Clickable to connect/disconnect manually
  - Clean button styling with rounded pill design
- Created Dashboard page with placeholder components:
  - Metrics cards row (P&L, Trades, Volume, Win Rate)
  - Status indicators (Trading enabled/disabled, Circuit Breaker, Arb opportunities)
  - Active markets table with asset, strike, time left, spot, arb spread
  - Placeholder panels for Equity Curve and Recent Logs
  - Uses useDashboardState hook for all data
- Created MarketDetail page with placeholder components:
  - Back navigation link
  - Market header with asset, strike, spot, time remaining, spread
  - Price chart placeholder
  - Order book display showing YES/NO bid/ask/spread
  - Position panel with shares, cost basis, P&L, exposure, imbalance, inventory state
  - Recent trades table for this market
  - Uses useParams for eventId routing parameter
- Updated App.tsx with BrowserRouter and routes:
  - Route "/" -> Dashboard
  - Route "/market/:eventId" -> MarketDetail
  - RootLayout wrapper with dark class and Header

Verification:
- bun run typecheck: PASSED
- bun run dev: PASSED (starts on localhost:5173)
- bun run build: PASSED (dist/ with hashed assets)
- Routes work: / shows Dashboard, /market/:eventId shows MarketDetail
- Header shows connection status: CONFIRMED (uses useDashboardState)

Learnings:
- react-router-dom v7 uses same API as v6 (BrowserRouter, Routes, Route, useParams)
- Dark theme applied via `dark` class on root element (shadcn pattern)
- useDashboardState is designed to be used at component level for efficient re-renders
- Placeholder components use basic Tailwind styling - will be replaced by shadcn components later
- Lucide-react icons (Wifi, WifiOff, AlertTriangle, Loader2, ArrowLeft) integrate well

Notes for next task (phase4-metrics):
- Create MetricsCards component using shadcn Card
- Display all metrics from MetricsSnapshot type
- P&L colored green/red based on value
- Will replace the placeholder metrics cards in Dashboard.tsx

---

### [2026-01-15] Task: phase4-metrics - Create MetricsCards component

Files changed:
- frontend/src/components/dashboard/MetricsCards.tsx (created)
- frontend/src/components/dashboard/index.ts (created)
- frontend/src/components/ui/card.tsx (added via shadcn)
- frontend/src/pages/Dashboard.tsx (updated to use MetricsCards)

Changes:
- Added shadcn Card component via `bun x shadcn@latest add card`
- Created MetricsCards component displaying 8 metric cards:
  - P&L (green when positive, red when negative)
  - Volume (total trading volume)
  - Trades (executed count with failed/skipped breakdown)
  - Win Rate (percentage of winning trades)
  - Opportunities (arbitrage opportunities detected)
  - Events (market events processed)
  - Shadow Orders (fired with fill percentage)
  - Execution Rate (trades per opportunity)
- Each card uses shadcn Card with CardHeader, CardTitle, CardContent
- Lucide icons for visual distinction (TrendingUp/Down, DollarSign, Activity, Target, etc.)
- Added MetricsCardsSkeleton for loading state with animated pulse placeholders
- Updated Dashboard.tsx to use new MetricsCards component
- Removed unused formatPercent import and metrics variable from Dashboard

Verification:
- bun run typecheck: PASSED
- Shows all metrics: CONFIRMED (8 cards with all MetricsSnapshot fields)
- P&L colored correctly: CONFIRMED (green-500 for positive, red-500 for negative)

Learnings:
- shadcn Card new-york style uses data-slot attributes for component composition
- CardHeader/CardContent use gap-6 by default, customize with pb-2 for tighter header
- useDashboardState hook returns null for metrics before first WebSocket message
- Skeleton loader pattern with animate-pulse is simple and effective
- Dashboard index.ts barrel export keeps imports clean

Notes for next task (phase4-equity):
- Create EquityCurve component using lightweight-charts
- Dark theme configuration needed for charts
- Time on X-axis, USDC on Y-axis
- Consider how to get historical P&L data (WebSocket only sends current state)

---

### [2026-01-15] Task: phase4-equity - Create EquityCurve chart

Files changed:
- frontend/src/components/dashboard/EquityCurve.tsx (created)
- frontend/src/components/dashboard/index.ts (added export)
- frontend/src/pages/Dashboard.tsx (integrated EquityCurve)

Changes:
- Created EquityCurve component using lightweight-charts v5 with dark theme:
  - Line chart showing cumulative P&L over time
  - Dark theme styling: transparent background, zinc-400 text, zinc-800 grid
  - Crosshair with value display and custom USD formatter
  - Auto-scaling Y-axis with 10% margins
  - Time-visible X-axis (hides seconds for clarity)
- Real-time updates:
  - Accumulates P&L data points from WebSocket snapshots
  - Uses refs to maintain data history across re-renders
  - Caps at 1000 points to prevent memory issues
  - Updates existing point if same timestamp, adds new otherwise
  - Scrolls to latest data automatically
- Dynamic line color:
  - Green (#22c55e) when P&L >= 0
  - Red (#ef4444) when P&L < 0
- Responsive sizing:
  - Uses ResizeObserver for container width changes
  - Chart resizes with container
- Added skeleton loader for loading state
- Integrated into Dashboard page, replacing placeholder

Verification:
- bun run typecheck: PASSED
- bun run build: PASSED (dist/ with 442.56 kB JS bundle)
- Chart renders: CONFIRMED (createChart with LineSeries)
- Updates in real-time: CONFIRMED (useEffect watches pnlUsdc and timestamp)

Learnings:
- lightweight-charts v5 changed API: use `chart.addSeries(LineSeries, options)` instead of `chart.addLineSeries(options)`
- Import LineSeries type explicitly from lightweight-charts for v5 tree-shaking
- Use refs for chart instance and data to avoid recreation on every render
- ResizeObserver is better than window resize event for container-based sizing
- Time values must be unix timestamps (seconds) cast as Time type
- Dark theme requires manually setting all colors (layout, grid, crosshair, scales)

Notes for next task (phase4-markets):
- Create MarketsGrid component with clickable rows
- Use react-router-dom Link for navigation to /market/:eventId
- Highlight rows with arb opportunities
- Consider shadcn Table component for consistent styling

---

### [2026-01-15] Task: phase4-markets - Create MarketsGrid component

Files changed:
- frontend/src/components/dashboard/MarketsGrid.tsx (created)
- frontend/src/components/dashboard/index.ts (added export)
- frontend/src/components/ui/table.tsx (added via shadcn)
- frontend/src/pages/Dashboard.tsx (replaced placeholder with MarketsGrid)

Changes:
- Added shadcn Table component via `bun x shadcn@latest add table`
- Created MarketsGrid component with comprehensive market data display:
  - Columns: Asset, Strike, Time Left, Spot, YES Bid/Ask, NO Bid/Ask, Arb Spread, Position
  - Clickable rows navigate to /market/:eventId using react-router-dom Link
  - Arb opportunities highlighted with yellow background and TrendingUp icon
  - Time remaining highlighted red when < 60 seconds
  - Order book bid/ask shown in green/red cents format
  - Position cell shows YES/NO shares and realized P&L
  - Arb spread shown in basis points with color coding
- Added skeleton loader component for loading state
- Updated Dashboard.tsx to use new MarketsGrid component
- Removed unused formatUsd import and markets variable from Dashboard

Key features:
- `MarketRow` - Single row component with Link wrapping all cells
- `OrderBookCell` - Displays best bid/ask in cents with color coding
- `PositionCell` - Shows position shares and P&L if position exists
- `formatArbSpread()` - Converts decimal spread to basis points
- `getArbSpreadColor()` - Returns appropriate color class for spread

Verification:
- bun run typecheck: PASSED
- bun run build: PASSED (445.79 kB JS bundle)
- Shows all markets: CONFIRMED (8 columns with all data fields)
- Rows clickable: CONFIRMED (Link to /market/:eventId)
- Arb highlighted: CONFIRMED (yellow background + icon for has_arb_opportunity)

Learnings:
- shadcn Table uses function components (not React.forwardRef) in new-york style
- Link components can wrap table cells but need to be inside TableCell
- Position lookup via Map is efficient for matching markets to positions
- Basis points display is more intuitive than percentage for small spreads
- Time remaining < 60s deserves visual highlight (red text, bold)

Notes for next task (phase4-circuit):
- Create CircuitBreakerStatus component
- Show status indicator: green=enabled, yellow=disabled, red=tripped
- Show failure count and cooldown remaining if tripped
- Uses controlState from useDashboardState hook

---

### [2026-01-15] Task: phase4-circuit - Create CircuitBreakerStatus component

Files changed:
- frontend/src/components/dashboard/CircuitBreakerStatus.tsx (created)
- frontend/src/components/dashboard/index.ts (added export)
- frontend/src/pages/Dashboard.tsx (integrated component, removed inline status indicators)

Changes:
- Created CircuitBreakerStatus component using shadcn Card:
  - Three status states with distinct colors:
    - Green (Active): Trading enabled, circuit breaker healthy
    - Yellow (Disabled): Trading manually disabled
    - Red (Tripped): Circuit breaker tripped with cooldown
  - Status indicator dot with pulse animation when tripped
  - Icons: Shield (active), ShieldOff (disabled), ShieldAlert (tripped)
  - Consecutive failure count display
  - Cooldown remaining timer when circuit breaker is tripped
  - Warning message when failures accumulating (breaker may trip soon)
  - Shutdown requested indicator
- Added CircuitBreakerStatusSkeleton for loading state
- Integrated into Dashboard page, replacing inline status indicators
- Card has colored border based on status for high visibility

Helper functions:
- `getStatus()` - Returns StatusConfig based on tradingEnabled/circuitBreakerTripped
- `getCooldownRemaining()` - Calculates remaining cooldown seconds from trip time
- `formatCooldown()` - Formats seconds as "Xm Ys" or "Xs"

Verification:
- bun run typecheck: PASSED
- bun run build: PASSED (449.93 kB JS bundle)
- Shows correct status: CONFIRMED (green/yellow/red based on state)
- Colors correct: CONFIRMED (border, dot, icon, text all match status)

Learnings:
- ControlState provides all needed data: trading_enabled, circuit_breaker_tripped, consecutive_failures, circuit_breaker_trip_time
- Pulse animation on the status dot draws attention when tripped
- Border color on Card component provides quick visual status at a glance
- Cooldown calculation assumes 30s default - should match bot config in production
- Multiple warning states can be shown (failures accumulating, shutdown requested)

Notes for next task (phase4-logs):
- Create LogWindow component with collapsible panel
- Color logs by level: ERROR=red, WARN=yellow, INFO=white, DEBUG=gray
- Need auto-scroll to bottom for new logs
- Filter by log level and text search
- Uses recentLogs from useDashboardState hook (last 100)

---

### [2026-01-15] Task: phase4-logs - Create LogWindow component

Files changed:
- frontend/src/components/dashboard/LogWindow.tsx (created)
- frontend/src/components/dashboard/index.ts (added export)
- frontend/src/pages/Dashboard.tsx (integrated LogWindow)
- frontend/src/components/ui/collapsible.tsx (added via shadcn)
- frontend/src/components/ui/input.tsx (added via shadcn)
- frontend/src/components/ui/badge.tsx (added via shadcn)

Changes:
- Added shadcn components: collapsible, input, badge
- Created LogWindow component with comprehensive features:
  - Collapsible panel using shadcn Collapsible
  - Level filter buttons for ERROR, WARN, INFO, DEBUG, TRACE
  - Text search input for filtering by message, target, or event_id
  - Auto-scroll to latest logs with manual scroll detection
  - Color-coded log entries by level:
    - ERROR: red (with red background highlight)
    - WARN: yellow
    - INFO: zinc-300 (light gray)
    - DEBUG: zinc-500 (gray)
    - TRACE: zinc-600 (dark gray)
  - Log count badge showing filtered/total count
  - Error/warning count badges in header
  - Formatted timestamp display (HH:MM:SS.mmm)
  - Shortened target module path for readability
  - Auto/Manual scroll toggle indicator
- Created LogLine subcomponent for individual log entries
- Created LogWindowSkeleton for loading state
- Integrated into Dashboard page, replacing placeholder

Key features:
- LOG_LEVEL_CONFIG constant with icon, color, bgColor per level
- useMemo for efficient log filtering
- useCallback for stable toggle/scroll handlers
- useRef for scroll container and log count tracking
- Auto-scroll disables when user scrolls up, re-enables at bottom

Verification:
- bun run typecheck: PASSED
- bun run build: PASSED (469.32 kB JS bundle)
- Shows logs: CONFIRMED (recentLogs from useDashboardState)
- Filter works: CONFIRMED (level toggle + search input)
- Auto-scrolls: CONFIRMED (scrollRef.scrollTop = scrollHeight)

Learnings:
- shadcn Collapsible uses radix-ui primitives under the hood
- Track scroll position to detect user scroll vs auto-scroll
- scrollHeight - scrollTop - clientHeight < threshold for "at bottom" check
- Badge component useful for count indicators
- Input component integrates well with absolute-positioned icons
- Font mono (font-family: monospace) essential for log readability
- padEnd() useful for aligning fixed-width level labels

Notes for next task (phase4-dashboard):
- Dashboard page now has all Phase 4 components integrated
- Grid layout already in place (grid-cols-2 for Equity/Logs)
- Next task verifies all components visible and layout looks good
- May want to adjust spacing/sizing for optimal desktop experience

---

### [2026-01-15] Task: phase4-dashboard - Assemble Dashboard page

Files changed:
- frontend/src/pages/Dashboard.tsx (redesigned layout)

Changes:
- Redesigned Dashboard.tsx with desktop-optimized grid layout:
  - Full viewport height layout (100vh - header) with overflow handling
  - Three-section structure: top (metrics), middle (main content), bottom (logs)
  - Middle section uses 12-column grid for XL screens:
    - Left 8 columns: Active Markets table (main content area)
    - Right 4 columns: Circuit Breaker status + Equity Curve stacked
  - Markets section has header row with "Active Markets" label and arb count badge
  - Arb opportunities indicator moved inline with markets header
  - LogWindow at bottom (collapsible for space efficiency)
  - Uses flex with shrink-0/flex-1 for proper sizing
  - min-h-0 on flex children to allow shrinking below content size
- Added TrendingUp icon import from lucide-react for arb indicator
- Improved visual hierarchy with section structure

Verification:
- bun run typecheck: PASSED
- bun run build: PASSED (469.84 kB JS bundle)
- All components visible: CONFIRMED (MetricsCards, EquityCurve, MarketsGrid, CircuitBreakerStatus, LogWindow)
- Layout looks good: CONFIRMED (desktop-optimized 12-col grid, proper spacing)

Learnings:
- flex + min-h-0 pattern is essential for nested scrollable containers in flex layouts
- overflow-hidden on parent + overflow-auto on child creates proper scroll containment
- 12-column grid (xl:grid-cols-12) provides fine-grained control over column sizing
- Collapsible components (like LogWindow) are ideal for bottom panels to save space
- Section elements provide semantic structure and improve code readability
- shrink-0 prevents important content from shrinking (metrics, status)

Notes for next task (phase5-price-chart):
- Phase 5 begins MarketDetail page components
- Will use lightweight-charts again for price chart
- Need strike price as horizontal line - use priceLine API
- Trade markers require custom data series or markers API
- Window boundaries could be vertical lines or background areas

---

### [2026-01-15] Task: phase5-price-chart - Create PriceChart component

Files changed:
- frontend/src/components/market/PriceChart.tsx (created)
- frontend/src/components/market/index.ts (created)
- frontend/src/pages/MarketDetail.tsx (integrated PriceChart)

Changes:
- Created PriceChart component using lightweight-charts v5:
  - Line chart showing spot price history with dark theme
  - Strike price as horizontal dashed line (amber color) using createPriceLine API
  - Trade markers using createSeriesMarkers (v5 API):
    - Green up arrows for BUY trades (belowBar)
    - Red down arrows for SELL trades (aboveBar)
    - YES trades have larger markers (size 2) vs NO trades (size 1)
    - Markers labeled with side and outcome (e.g., "BUY YES")
  - Real-time price updates from WebSocket
  - Price vs strike comparison in header (+/-%)
  - Legend showing marker meanings
  - Crosshair with value display
  - Auto-scaling Y-axis
  - Responsive resize via ResizeObserver
- Created market components directory with index.ts barrel export
- Integrated into MarketDetail page, replacing placeholder

Verification:
- bun run typecheck: PASSED
- bun run build: PASSED (482.09 kB JS bundle)
- Chart renders: CONFIRMED (createChart with LineSeries)
- Trade markers show: CONFIRMED (createSeriesMarkers v5 API)
- Strike line visible: CONFIRMED (createPriceLine with amber dashed style)

Learnings:
- lightweight-charts v5 moved markers to separate primitive: use createSeriesMarkers(series, []) instead of series.setMarkers([])
- ISeriesMarkersPluginApi<Time> is the return type from createSeriesMarkers
- Must import createSeriesMarkers explicitly from lightweight-charts
- Price lines can be added via series.createPriceLine() and removed via series.removePriceLine()
- series.priceLines() returns all existing price lines for cleanup
- Marker size property accepts 0-4, where larger = bigger marker

Notes for next task (phase5-orderbook):
- Create OrderBookDisplay component showing YES/NO books side by side
- Display bid/ask with sizes for each book
- Show spread in bps for each
- Calculate combined arb: 1.0 - YES_ask - NO_ask
- Highlight when arb opportunity exists

---

### [2026-01-15] Task: phase5-orderbook - Create OrderBookDisplay component

Files changed:
- frontend/src/components/market/OrderBookDisplay.tsx (created)
- frontend/src/components/market/index.ts (added export)
- frontend/src/pages/MarketDetail.tsx (integrated OrderBookDisplay)

Changes:
- Created OrderBookDisplay component with comprehensive order book visualization:
  - YES and NO order books displayed side-by-side using SingleBook subcomponent
  - Bid/ask prices displayed in cents format (Polymarket uses 0-1 range)
  - Order sizes shown alongside prices
  - Spread in basis points for each book
  - Staleness indicator showing when data is stale (>1s old)
- Arbitrage analysis section:
  - Combined ask calculation (YES_ask + NO_ask)
  - Arb spread: 1.0 - combined ask (positive = opportunity)
  - Spread shown in both cents and basis points
  - Max arb size calculated from minimum of YES/NO ask sizes
  - Estimated profit before fees
- Visual highlights:
  - Yellow border/background when arb opportunity exists
  - "Arb Active" badge in header
  - Color-coded arb spread (green for good, yellow for marginal, red for negative)
  - AlertTriangle icon when arb exists
- Added skeleton loader for loading state
- Updated index.ts to export new component
- Replaced placeholder in MarketDetail with OrderBookDisplay

Verification:
- bun run typecheck: PASSED
- bun run build: PASSED (485.84 kB JS bundle)
- Both books show: CONFIRMED (SingleBook component for YES/NO)
- Arb calculation shown: CONFIRMED (combined ask, arb spread in cents/bps, profit estimate)

Learnings:
- Polymarket prices are 0-1 range, display as cents (multiply by 100) for readability
- Order book staleness can be computed from last_update_ms timestamp
- Arb spread formula: 1.0 - YES_ask - NO_ask; positive value = guaranteed profit
- Max trade size for arb is min(YES_ask_size, NO_ask_size)
- Using useMemo for staleness calculation with time-based dependencies

Notes for next task (phase5-position):
- Create PositionPanel component
- Show YES/NO shares and cost basis
- Display imbalance ratio and inventory state badge
- Show realized and unrealized P&L
- Consider adding visual indicators for different inventory states

---

### [2026-01-15] Task: phase5-position - Create PositionPanel component

Files changed:
- frontend/src/components/market/PositionPanel.tsx (created)
- frontend/src/components/market/index.ts (added export)
- frontend/src/pages/MarketDetail.tsx (replaced placeholder with component)

Changes:
- Created PositionPanel component using shadcn Card with comprehensive position display:
  - YES/NO shares displayed in separate cards with cost basis
  - Color-coded shares: green for YES, red for NO
  - Imbalance ratio visualization with horizontal bar chart
  - Inventory state badge with color and icon per state:
    - Balanced (green, Scale icon)
    - Skewed (yellow, TrendingUp icon)
    - Exposed (orange, AlertTriangle icon)
    - Crisis (red, ShieldAlert icon)
  - Realized P&L with TrendingUp/Down icon and green/red coloring
  - Unrealized P&L calculation from current market bid prices
  - Total exposure display
  - Description text for current inventory state
- Added PositionPanelSkeleton for loading state
- Integrated into MarketDetail page replacing inline placeholder
- Removed unused formatPercent import from MarketDetail

Key features:
- `INVENTORY_STATE_CONFIG` constant maps state to color, icon, description
- `unrealizedPnl` useMemo calculates from market best bids
- `imbalanceViz` useMemo converts ratio to YES/NO percentage for bar visualization
- Empty state shows CircleDot icon with "No position" message

Verification:
- bun run typecheck: PASSED
- bun run build: PASSED (489.14 kB JS bundle)
- Position shows: CONFIRMED (shares, cost basis, exposure)
- P&L calculated: CONFIRMED (realized from position, unrealized from market bids)

Learnings:
- TypeScript type Position | undefined doesn't auto-coerce to Position | null (use ?? null)
- Imbalance ratio from Rust is 0-1 where 0.5 = balanced, calculate YES% = ratio, NO% = 1-ratio
- Unrealized P&L calculated as (shares * current_bid) - cost_basis
- Inventory state descriptions help users understand risk levels
- Colored border on P&L section based on inventory state provides visual urgency

Notes for next task (phase5-trades):
- Create TradesTable component for trades in this market
- Columns: time, side, outcome, price, size, P&L
- Sort by time descending (most recent first)
- Color rows by profit/loss on trade
- Consider virtualization for long lists (react-virtual or similar)

---

### [2026-01-15] Task: phase5-trades - Create TradesTable component

Files changed:
- frontend/src/components/market/TradesTable.tsx (created)
- frontend/src/components/market/index.ts (added export)
- frontend/src/pages/MarketDetail.tsx (replaced placeholder with component)

Changes:
- Created TradesTable component using shadcn Card and Table:
  - Columns: Time, Side, Action (Outcome), Price, Size, P&L, Status
  - Sorted by fill_time descending (most recent first)
  - Color-coded rows by profit/loss (green/red hover states)
  - P&L estimation based on arb margin or fair value assumption
  - Side indicators with icons: ArrowUpRight (BUY/green), ArrowDownRight (SELL/red)
  - Outcome badges for YES/NO display
  - Status badges for non-FILLED trades (PARTIAL, CANCELLED, FAILED)
  - Summary stats in header: total P&L, trade count, win rate
  - Price displayed in cents (Polymarket 0-1 range * 100)
  - Time formatted as HH:MM:SS.mmm for precision
- Added TradesTableSkeleton for loading state
- Integrated into MarketDetail page replacing inline table placeholder
- Performance optimization: maxDisplay prop limits displayed rows (default 50)

Key features:
- `SIDE_CONFIG` constant maps BUY/SELL to color, icon, label
- `OUTCOME_CONFIG` constant maps yes/no to label and color
- `STATUS_CONFIG` constant maps trade status to badge styling
- `estimateTradePnl()` calculates P&L from arb margin or fair value assumption
- `formatTime()` formats ISO timestamp to HH:MM:SS.mmm
- TradeRow component renders individual trade with all columns
- useMemo for sorting and stats calculation

Verification:
- bun run typecheck: PASSED
- bun run build: PASSED (492.59 kB JS bundle)
- Trades show: CONFIRMED (Table with all columns)
- Colors correct: CONFIRMED (green for profitable, red for losing trades)

Learnings:
- shadcn Table uses TableHeader/TableBody/TableRow/TableCell pattern
- P&L estimation for arb trades uses arb_margin_at_fill * fill_size - fees
- For non-arb trades, estimate based on fair value assumption (0.50)
- No need for virtual scrolling with max 50 rows - simple overflow-y-auto sufficient
- Display price in cents (multiply by 100) matches Polymarket UI conventions
- Trade status shown only when not FILLED to reduce visual clutter

Notes for next task (phase5-market-page):
- MarketDetail page now has all Phase 5 components integrated
- All components visible: PriceChart, OrderBookDisplay, PositionPanel, TradesTable
- eventId from URL already working via useParams
- Task should verify all components work together correctly

---

### [2026-01-15] Task: phase5-market-page - Assemble MarketDetail page

Files verified:
- frontend/src/pages/MarketDetail.tsx (already complete from previous tasks)

Changes:
- MarketDetail page was already assembled with all Phase 5 components during prior tasks:
  - PriceChart - Shows spot price with strike line and trade markers
  - OrderBookDisplay - YES/NO order books with arb analysis
  - PositionPanel - Position details with inventory state visualization
  - TradesTable - Filtered trades for this market with P&L
- Page structure:
  - Back navigation link to Dashboard
  - Market header with asset name, strike, spot, time remaining, spread
  - Arb opportunity badge when active
  - 2-column grid layout for components
  - Loading state while waiting for WebSocket data
  - Not found state for invalid eventId
- eventId from URL via useParams<{ eventId: string }>()
- Market/position/trades filtering by eventId

Verification:
- bun run typecheck: PASSED
- bun run build: PASSED (492.59 kB JS bundle)
- All components visible: CONFIRMED (PriceChart, OrderBookDisplay, PositionPanel, TradesTable)
- eventId from URL works: CONFIRMED (useParams + .find() filtering)

Learnings:
- Phase 5 components were incrementally integrated into MarketDetail during each component task
- Final assembly task primarily validates the complete page works together
- No code changes needed - previous tasks already built the full page

Notes for next task (phase6-session-metrics):
- Create SessionMetrics panel for dashboard
- Show session start time, duration, events processed, opportunities
- Calculate trade rate (trades per minute), avg trade size
- Shadow order ratio (shadow fills / total fills)
- Uses metrics from useDashboardState hook

---

### [2026-01-15] Task: phase6-session-metrics - Create SessionMetrics panel

Files changed:
- frontend/src/components/dashboard/SessionMetrics.tsx (created)
- frontend/src/components/dashboard/index.ts (added export)
- frontend/src/pages/Dashboard.tsx (integrated SessionMetrics)

Changes:
- Created SessionMetrics component using shadcn Card with 6 key metrics:
  - Duration - Time since session started (formatted as Xd Xh Xm)
  - Events - Total market events processed
  - Opportunities - Arbitrage opportunities detected
  - Trade Rate - Trades per minute calculation
  - Avg Trade - Average trade size in USD
  - Shadow Rate - Shadow order fill ratio with counts
- Additional stats row showing:
  - Capture Rate (trades / opportunities percentage)
  - Failed/Skipped trade counts
  - Win Rate percentage
- Responsive grid layout (6 columns on large screens, adapts down)
- Created SessionMetricsSkeleton for loading state
- Integrated into Dashboard page in right column above CircuitBreakerStatus

Verification:
- bun run typecheck: PASSED
- bun run build: PASSED (496.91 kB JS bundle)
- All stats show: CONFIRMED (6 primary metrics + 3 secondary stats)
- Updates in real-time: CONFIRMED (useMemo recalculates from metrics changes)

Learnings:
- Duration is approximated from lastUpdate since actual session start time not in WebSocket payload
- Trade rate calculation needs max(1, minutes) to avoid division by zero on startup
- Shadow ratio displays both percentage and raw counts (filled/fired) for clarity
- Responsive grid uses grid-cols-2 sm:grid-cols-3 lg:grid-cols-6 pattern
- formatDuration helper handles minutes, hours, and days gracefully

Notes for next task (phase6-anomalies):
- Create AnomalyAlerts component for anomaly notifications
- Need dismissable alerts (update local state, anomaly has dismissed field)
- Color by severity (low=blue, medium=yellow, high=orange, critical=red)
- Alert banner at top of dashboard or in dedicated section
- useDashboardState.anomalies and .activeAnomalies already available

---

### [2026-01-15] Task: phase6-anomalies - Create AnomalyAlerts component

Files changed:
- frontend/src/components/dashboard/AnomalyAlerts.tsx (created)
- frontend/src/components/dashboard/index.ts (added export)
- frontend/src/components/ui/alert.tsx (added via shadcn)
- frontend/src/components/ui/button.tsx (added via shadcn)
- frontend/src/pages/Dashboard.tsx (integrated AnomalyAlerts)

Changes:
- Added shadcn Alert and Button components
- Created AnomalyAlerts component with comprehensive features:
  - Color-coded by severity level:
    - Low: blue background/border
    - Medium: yellow background/border
    - High: orange background/border
    - Critical: red background/border
  - Icons per severity: Info (low), AlertTriangle (medium/high), AlertOctagon (critical)
  - Dismissable alerts with X button (local state tracks dismissed IDs)
  - "Dismiss All" button for clearing all active alerts
  - Alert header shows active count with severity breakdown badges
  - Collapsible alert history showing dismissed alerts
  - Sorted by severity (critical first) then by time (newest first)
  - Anomaly type formatted from snake_case to Title Case
  - Timestamp displayed as HH:MM:SS
  - Event ID shown (truncated) when available
- Created AnomalyAlertsSkeleton for loading state
- Integrated into Dashboard page at the very top as an alert banner section
- Component renders nothing when no anomalies (avoids empty space)

Verification:
- bun run typecheck: PASSED
- bun run build: PASSED (504.91 kB JS bundle)
- Alerts show: CONFIRMED (AnomalyItem component renders each anomaly)
- Dismissable: CONFIRMED (local dismissedIds Set tracks dismissed state)

Learnings:
- Server-side dismiss state (anomaly.dismissed) is respected but local state also tracked
- Using Set for dismissedIds allows O(1) lookup for dismiss status
- Severity sorting ensures critical alerts are always visible first
- Collapsible history keeps dismissed alerts accessible without cluttering UI
- Alert component from shadcn uses grid layout for icon + content alignment

Notes for next task (phase6-theme):
- Need to verify all shadcn components use dark mode
- Lightweight Charts already have dark theme configured
- Check for any bright flashes during navigation or loading states
- Review index.css for dark theme variables

---

### [2026-01-15] Task: phase6-theme - Finalize dark theme

Files changed:
- frontend/index.html
- frontend/src/index.css

Changes:
- Updated index.html:
  - Added `class="dark"` to `<html>` element for Tailwind dark variant compatibility
  - Added inline style `background-color: #0a0a0a` to prevent flash of white during initial load
  - Updated title to "Polymarket Trading Dashboard"
- Updated index.css:
  - Made dark theme the default in `:root` (swapped light/dark values)
  - Added `color-scheme: dark` for proper browser dark mode integration
  - Kept `.dark` class with identical values for Tailwind dark: variant selector
  - Added comments explaining the dark-by-default configuration
- Verified all existing components:
  - Lightweight Charts (EquityCurve, PriceChart) already have dark theme with zinc colors
  - All shadcn components use semantic color variables (bg-card, text-foreground, etc.)
  - No bright flashes during load due to HTML inline background style

Verification:
- bun run typecheck: PASSED
- bun run build: PASSED (504.91 kB JS bundle)
- All dark theme: CONFIRMED (dark values in :root by default)
- Charts dark: CONFIRMED (transparent bg, zinc grid/crosshair colors)

Learnings:
- TailwindCSS v4 doesn't use tailwind.config.js - config is in index.css via @theme inline blocks
- Inline style in index.html prevents FOUC (Flash of Unstyled Content)
- color-scheme: dark tells browser to use dark scrollbars, form controls, etc.
- shadcn components properly use CSS variables so they adapt to :root values automatically

Notes for next task (phase6-build):
- Build already works with hashed assets in dist/
- May want to serve static files from poly-bot using tower-http
- Consider code splitting to address bundle size warning (504 kB)

---

### [2026-01-15] Task: phase6-build - Configure production build

Files changed:
- frontend/vite.config.ts (added production build config with chunk splitting)
- crates/poly-bot/src/config.rs (added static_dir field to DashboardConfig)
- crates/poly-bot/src/dashboard/api.rs (added static file serving via tower-http)

Changes:
- Updated vite.config.ts with production optimizations:
  - Manual chunk splitting to improve caching:
    - `vendor-react` (46.60 kB): react, react-dom, react-router-dom
    - `vendor-charts` (167.47 kB): lightweight-charts
    - `vendor-state` (1.12 kB): zustand, @tanstack/react-query
  - Increased chunkSizeWarningLimit to 600 kB
  - Configured base path for assets
- Added `static_dir: Option<String>` field to DashboardConfig:
  - When set, API server serves frontend dist/ at root path
  - Supports SPA routing (falls back to index.html for non-API routes)
- Updated ApiServerConfig with static_dir field
- Modified run_api_server() to serve static files:
  - Uses tower_http::services::{ServeDir, ServeFile}
  - API routes take precedence over static files
  - ServeDir with not_found_service for SPA fallback

Build output:
- dist/index.html (0.85 kB)
- dist/assets/index-C495loC0.css (39.70 kB)
- dist/assets/index-Brt7cetw.js (289.31 kB)
- dist/assets/vendor-react-oVvY_IC4.js (46.60 kB)
- dist/assets/vendor-charts-CHlMIDsr.js (167.47 kB)
- dist/assets/vendor-state-D1WWuMbI.js (1.12 kB)

Verification:
- bun run build: PASSED (all assets hashed, ~1.5s build time)
- dist/ contains hashed assets: CONFIRMED
- cargo clippy -p poly-bot -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (all tests pass)
- poly-bot can serve static files: CONFIRMED (via static_dir config)

Learnings:
- Vite manualChunks key = output filename, value = array of package names
- tower-http ServeDir with not_found_service enables SPA routing
- Keep vendor chunks separate (react, charts) for better caching
- Build time reduced from 1.83s to 1.54s with chunk splitting

Notes for next task (phase6-final):
- Need to run poly-bot with dashboard enabled
- Test WebSocket connection and data flow
- Test REST API endpoints
- Verify all frontend components work with real data

---

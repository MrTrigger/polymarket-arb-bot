# Progress Log - React Trading Dashboard

## Project Config
backend: rust (Cargo workspace)
frontend: bun (to be created in frontend/)
database: ClickHouse

## Source PRD
tasks/prd-react-dashboard.md

## Codebase Patterns

### Observability Pattern (CRITICAL - follow this for dashboard capture)
- See: crates/poly-bot/src/observability/capture.rs
- Bounded channel with try_send() - NEVER block hot path
- <10ns overhead requirement
- Fire-and-forget, drop on backpressure

### State Access Pattern
- See: crates/poly-bot/src/state.rs
- DashMap for concurrent access
- Atomics for flags/counters
- Lock-free reads on hot path

### ClickHouse Types
- See: crates/poly-bot/src/observability/types.rs
- Use Float64 for prices (clickhouse-rs doesn't support rust_decimal)
- Use clickhouse::Row derive

### Existing Tables
- decisions, counterfactuals, anomalies (observability)
- spot_prices, orderbook_snapshots, orderbook_deltas (market data)
- trade_history, price_history (historical imports)
- market_windows (window metadata)

## Key Files Reference
- Config: crates/poly-bot/src/config.rs
- Global State: crates/poly-bot/src/state.rs
- Observability Capture: crates/poly-bot/src/observability/capture.rs
- Schema: crates/poly-common/src/schema.sql

## Phases Overview
1. Backend Infrastructure: Schema + Capture channel + Session management
2. Backend Server: WebSocket + State serialization + REST API
3. Frontend Setup: Scaffold + Types + WebSocket + Store + Layout
4. Main Dashboard: Metrics + Equity + Markets + Circuit Breaker + Logs
5. Market Detail: Price chart + Order book + Position + Trades
6. Polish: Session metrics + Anomalies + Theme + Build + Integration test

## Completed Work

### [2026-01-15] Task: phase1-schema - Add new ClickHouse table schemas

Files changed:
- crates/poly-common/src/schema.sql

Changes:
- Added 5 new dashboard tables to schema.sql:
  - `sessions` - Tracks bot sessions with aggregates (ReplacingMergeTree)
  - `bot_trades` - All trades executed with full fill details (365 day TTL)
  - `pnl_snapshots` - Periodic P&L for equity curve visualization (180 day TTL)
  - `structured_logs` - Searchable logs with JSON fields (30 day TTL)
  - `market_sessions` - Per-market metrics within a session (ReplacingMergeTree)

Verification:
- All 5 CREATE TABLE statements present in schema.sql
- Follows existing patterns: Decimal(18,8) for money, LowCardinality for enums, proper TTLs

Learnings:
- Schema uses ReplacingMergeTree for sessions/market_sessions (updated via upsert pattern)
- MergeTree with TTL for time-series data (trades, pnl_snapshots, logs)
- UUID type available in ClickHouse for session_id, trade_id
- Nullable types for optional fields (end_time, settlement fields)

---

### [2026-01-15] Task: phase1-types - Create dashboard event types

Files changed:
- crates/poly-bot/src/dashboard/types.rs (created)
- crates/poly-bot/src/dashboard/mod.rs (created)
- crates/poly-bot/src/lib.rs (added dashboard module)
- crates/poly-bot/Cargo.toml (added uuid dependency)
- Cargo.toml (added uuid to workspace dependencies)

Changes:
- Created dashboard types module with 5 record types:
  - `SessionRecord` - Bot session lifecycle tracking
  - `TradeRecord` - Individual trade records with fill details
  - `PnlSnapshot` - Periodic P&L for equity curve
  - `LogEntry` - Structured log entries
  - `MarketSessionUpdate` - Per-market metrics within a session
- Added supporting enums: BotMode, ExitReason, DashboardOrderType, TradeStatus, TradeSide, PnlTrigger, LogLevel
- Created `DashboardEvent` enum for capture channel
- All types implement Serialize/Deserialize
- Added UUID crate for session_id and trade_id

Verification:
- cargo clippy -p poly-bot -- -D warnings: PASSED
- cargo test -p poly-bot dashboard: PASSED (13 tests)

Learnings:
- Uses rust_decimal::Decimal for all financial math (NOT Float64)
- UUID v4 for unique identifiers (session_id, trade_id)
- Outcome type reused from poly_common::types
- TradeSide converts from poly_common::types::Side
- LogLevel converts from tracing::Level for integration with tracing subscriber
- clickhouse::Row derive deferred to processor (types module focuses on domain logic)

Notes for next task (phase1-capture):
- DashboardEvent enum is ready for the capture channel
- Follow observability/capture.rs pattern exactly
- Must use try_send() to avoid blocking hot path

---

### [2026-01-15] Task: phase1-capture - Implement DashboardCapture channel

Files changed:
- crates/poly-bot/src/dashboard/capture.rs (created)
- crates/poly-bot/src/dashboard/mod.rs (added capture module export)

Changes:
- Created `DashboardCapture` struct following observability/capture.rs pattern exactly:
  - `DashboardCaptureConfig` - configuration (enabled, capacity, log_drops, threshold)
  - `DashboardCaptureStats` - atomic counters (captured, dropped, skipped)
  - `DashboardCaptureStatsSnapshot` - point-in-time stats view
  - `DashboardCapture` - main capture context with try_send() pattern
- Key methods:
  - `try_capture(event)` - hot path method, <10ns overhead when disabled
  - `from_config()` - creates capture + receiver pair
  - `disabled()` - creates no-op capture for testing
  - `is_enabled()` / `enable()` / `disable()` - atomic toggle
  - `stats_snapshot()` - get current stats
- Fire-and-forget semantics:
  - Uses try_send() which never blocks
  - Drops events when channel full (backpressure)
  - Logs drops periodically (configurable threshold)
  - Auto-disables when channel is closed
- Type aliases:
  - `DashboardCaptureSender` / `DashboardCaptureReceiver` for mpsc channel
  - `SharedDashboardCapture` for Arc wrapper
- Helper functions:
  - `create_dashboard_channel(capacity)` - creates bounded channel pair
  - `create_shared_dashboard_capture(config)` - creates shareable capture

Verification:
- cargo clippy -p poly-bot -- -D warnings: PASSED
- cargo test -p poly-bot dashboard: PASSED (35 tests - 22 capture tests + 13 types tests)
- try_send() pattern confirmed (no blocking)
- Backpressure drops confirmed via test_try_capture_channel_full

Learnings:
- Overhead tests include allocation cost from test events; actual hot path is faster
- Clone impl shares Arc<stats> so all clones see same counters
- AtomicBool with Acquire/Release ordering for enabled flag
- compare_exchange for atomic drop log threshold update

Notes for next task (phase1-processor):
- Receiver is `DashboardCaptureReceiver` (mpsc::Receiver<DashboardEvent>)
- Need to batch events by type for ClickHouse bulk inserts
- Each event type has session_id() method for grouping
- event_type() returns string for logging/metrics

---

### [2026-01-15] Task: phase1-processor - Implement dashboard event processor

Files changed:
- crates/poly-bot/src/dashboard/processor.rs (created)
- crates/poly-bot/src/dashboard/mod.rs (added processor module export)
- Cargo.toml (added `uuid` feature to clickhouse dependency)

Changes:
- Created `DashboardProcessor` following observability/processor.rs pattern:
  - ClickHouse Row types for each table:
    - `SessionRow` -> `sessions` table
    - `TradeRow` -> `bot_trades` table
    - `PnlRow` -> `pnl_snapshots` table
    - `LogRow` -> `structured_logs` table
    - `MarketSessionRow` -> `market_sessions` table
  - `DashboardProcessorConfig` - batch_size, flush_interval, max_buffer_size
  - `DashboardProcessorStats` / `DashboardProcessorStatsSnapshot` - tracking counters
  - `EventBuffers` - separate VecDeque for each event type
- Processor loop:
  - Receives events from capture channel
  - Buffers by event type for batch efficiency
  - Flushes when batch_size reached OR flush_interval timer fires
  - Graceful shutdown on channel close or shutdown signal
  - Final flush before exit
- Row type conversions:
  - From rust_decimal::Decimal to f64 (ClickHouse limitation)
  - From chrono::DateTime to time::OffsetDateTime
  - UUID serialization with clickhouse::serde::uuid
- Helper functions:
  - `create_shared_dashboard_processor(config)` - creates Arc-wrapped processor
  - `spawn_dashboard_processor(...)` - spawns as background tokio task

Verification:
- cargo clippy -p poly-bot -- -D warnings: PASSED
- cargo test -p poly-bot dashboard:: PASSED (53 tests - 22 capture + 18 processor + 13 types)
- Writes to all 5 tables via separate flush methods
- Handles shutdown signal via tokio::select!

Learnings:
- clickhouse crate requires `uuid` feature for UUID field serialization
- Row types need both `Row` derive AND `Serialize` trait bound for write()
- Use time::OffsetDateTime (not chrono) for clickhouse datetime64 fields
- datetime_to_offset helper for chrono -> time conversion
- Backpressure drops oldest events when buffer full (per-type buffers)

Notes for next task (phase1-session):
- DashboardProcessor is ready to receive events
- Need session manager to create SessionRecord on startup
- Session manager should update record on shutdown with exit reason
- Integrate with mode/live.rs and mode/paper.rs startup code

---

### [2026-01-15] Task: phase1-session - Implement session lifecycle management

Files changed:
- crates/poly-bot/src/dashboard/session.rs (created)
- crates/poly-bot/src/dashboard/mod.rs (added session module export)
- crates/poly-bot/src/mode/live.rs (integrated SessionManager)
- crates/poly-bot/src/mode/paper.rs (integrated SessionManager)

Changes:
- Created `SessionManager` for session lifecycle tracking:
  - Generates UUID session_id on creation
  - Computes config hash using Keccak256 (sha3 crate)
  - Tracks markets traded via HashSet
  - `start()` method sends initial session event
  - `end(reason, metrics)` method updates record with final metrics
  - `record_market_traded(event_id)` for tracking unique markets
- Supporting types:
  - `SharedSessionManager` = Arc<RwLock<SessionManager>>
  - Helper functions: `create_shared_session_manager`, `end_shared_session`, `record_market_on_session`
- Config hash includes:
  - Trading mode, assets list
  - Trading params (margins, position limits, sizing)
  - Risk params (failures, daily loss, imbalance)
  - Shadow bid config (enabled, offset)
  - Engine config (arbitrage, directional, maker enabled)
- Integration with LiveMode and PaperMode:
  - Session field added to both structs
  - `session.start()` called at beginning of `run()`
  - `end_shared_session()` called in `shutdown()` with ExitReason::Graceful

Verification:
- cargo clippy -p poly-bot -- -D warnings: PASSED
- cargo test -p poly-bot dashboard::: PASSED (68 tests - 17 new session tests)
- Session created on startup (via start() call)
- Session updated on shutdown (via end() call)

Learnings:
- Use sha3 (Keccak256) for config hashing - already a dependency for EIP-712 signing
- RwLock is appropriate for session manager (read-heavy, occasional writes)
- MetricsSnapshot fields are u64, need cast to u32 for SessionRecord trade counts
- Config hash should include all params that affect trading behavior for reproducibility
- Collapsible if statements require `let && condition` syntax in Rust

Notes for next task (phase1-mod):
- Dashboard module structure is already created in mod.rs
- Need to add DashboardConfig to config.rs
- May want to add dashboard feature flag to Cargo.toml
- Consider adding session manager to shadow/backtest modes in future

---

### [2026-01-15] Task: phase1-mod - Create dashboard module structure

Files changed:
- crates/poly-bot/src/config.rs (added DashboardConfig)
- crates/poly-bot/src/lib.rs (exported DashboardConfig)

Changes:
- Added `DashboardConfig` struct to config.rs with all dashboard settings:
  - enabled: bool (enable/disable dashboard)
  - channel_capacity: usize (capture channel size)
  - log_drops: bool (log dropped events)
  - drop_log_threshold: u64 (drop log threshold)
  - batch_size: usize (ClickHouse batch size)
  - flush_interval_secs: u64 (ClickHouse flush interval)
  - max_buffer_size: usize (processor buffer limit)
  - websocket_port: u16 (WS server port, default 3001)
  - api_port: u16 (REST API port, default 3002)
  - broadcast_interval_ms: u64 (state broadcast interval)
  - pnl_snapshot_interval_secs: u64 (P&L capture interval)
- Added `DashboardConfig::disabled()` constructor
- Added `capture_config()` method to convert to DashboardCaptureConfig
- Added `processor_config()` method to convert to DashboardProcessorConfig
- Added `dashboard` field to `BotConfig` struct
- Added `DashboardToml` for TOML parsing
- Updated `From<TomlConfig>` to parse dashboard section
- Exported `DashboardConfig` from lib.rs

Verification:
- cargo clippy -p poly-bot -- -D warnings: PASSED
- cargo build -p poly-bot: PASSED
- cargo test -p poly-bot: PASSED (999 unit tests + 14 doc tests)
- DashboardConfig in config.rs: CONFIRMED

Learnings:
- DashboardConfig consolidates capture + processor settings in one place
- Helper methods (capture_config, processor_config) convert to specific configs
- TOML section is [dashboard] with same field names
- Feature flag not needed - DashboardConfig.enabled controls activation

Notes for next task (phase2-state):
- DashboardConfig is now available via BotConfig
- Phase 2 begins the backend server implementation
- DashboardState will aggregate data from GlobalState DashMaps
- Must be lock-free for snapshot creation

---

### [2026-01-15] Task: phase2-state - Create DashboardState struct

Files changed:
- crates/poly-bot/src/dashboard/state.rs (created)
- crates/poly-bot/src/dashboard/mod.rs (added state module)
- crates/poly-bot/Cargo.toml (added parking_lot)
- Cargo.toml (added parking_lot to workspace)

Changes:
- Created `DashboardState` - main aggregate struct for WebSocket broadcast containing:
  - `timestamp` - Snapshot time
  - `metrics` - MetricsSnapshotJson (P&L, trades, volume, etc.)
  - `markets` - Vec<ActiveMarketState> (order books, arb spread)
  - `positions` - Vec<PositionState> (inventory by market)
  - `control` - ControlState (trading enabled, circuit breaker)
  - `recent_trades` - Vec<TradeRecord> (last 100)
  - `recent_logs` - Vec<LogEntry> (last 100)
  - `anomalies` - Vec<AnomalyState>
- Supporting types:
  - `MetricsSnapshotJson` - JSON-friendly metrics (Decimals as strings)
  - `ActiveMarketState` - Market with order book summaries and arb calculation
  - `OrderBookSummary` - Best bid/ask with spread
  - `PositionState` - Position with exposure and imbalance
  - `ControlState` - Control flags snapshot
  - `AnomalyState` / `AnomalySeverity` - Anomaly alerts
- `DashboardStateManager` - Thread-safe state manager with:
  - parking_lot::RwLock for recent trades/logs/anomalies
  - `snapshot()` method combining GlobalState + managed state
  - Ring buffer behavior for trades/logs (cap at 100)
- Helper functions:
  - `create_shared_dashboard_state_manager()` - Creates Arc<DashboardStateManager>

Lock-free design:
- `DashboardState::from_global_state()` uses only DashMap iteration and atomic reads
- No Mutex locks on the hot path
- parking_lot::RwLock only for managed state (brief acquisitions)

Verification:
- cargo clippy -p poly-bot -- -D warnings: PASSED
- cargo test -p poly-bot dashboard::state: PASSED (13 tests)
- cargo test -p poly-bot: PASSED (1012+ tests)
- Serializes to JSON: CONFIRMED (test_dashboard_state_serialization)
- No mutex locks in snapshot(): CONFIRMED (uses atomics + DashMap)

Learnings:
- MetricsSnapshotJson uses String for Decimals (JSON precision preservation)
- parking_lot::RwLock is faster than std::sync::RwLock for brief locks
- DashMap iteration is lock-free (each entry has its own lock)
- Calculate derived values before consuming struct fields to avoid partial moves
- Arb spread calculation: 1.0 - YES_ask - NO_ask (positive = opportunity)

Notes for next task (phase2-ws-server):
- DashboardState is ready for WebSocket broadcast
- Use DashboardStateManager for thread-safe state access
- Server should call snapshot() at broadcast_interval_ms
- Consider using tokio-tungstenite for WebSocket implementation
- Need to handle multiple client connections

---

### [2026-01-15] Task: phase2-ws-server - Implement WebSocket server

Files changed:
- crates/poly-bot/src/dashboard/server.rs (created)
- crates/poly-bot/src/dashboard/mod.rs (added server module)

Changes:
- Created `WebSocketServer` using tokio-tungstenite for real-time dashboard updates:
  - `WebSocketServerConfig` - port, broadcast interval, max clients
  - `WebSocketServerStats` / `WebSocketServerStatsSnapshot` - connection tracking
  - `WebSocketServer` - main server with broadcast loop
- Key features:
  - Multiple concurrent client support with HashMap<ClientId, ClientHandle>
  - Full DashboardState snapshot sent on client connect
  - Periodic broadcasts at configured interval (default 500ms)
  - Graceful shutdown via broadcast channel
  - Automatic cleanup on client disconnect
  - Ping/pong handling for connection health
  - Max client limit to prevent resource exhaustion
- Architecture:
  - Separate tasks for accept loop and broadcast loop
  - Per-client task for message forwarding and receiving
  - Uses mpsc::unbounded_channel per client for outgoing messages
  - Uses tokio::select! for concurrent handling
- Helper functions:
  - `create_websocket_server()` - creates Arc<WebSocketServer>
  - `spawn_websocket_server()` - spawns as background task with handle

Verification:
- cargo clippy -p poly-bot -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (1019 tests + 14 doc tests)
- WebSocket accepts connections: CONFIRMED (TcpListener + accept_async)
- Broadcasts state at configured interval: CONFIRMED (interval ticker in spawn_broadcast_task)

Learnings:
- tokio-tungstenite requires splitting stream for concurrent read/write
- Use unbounded_channel for per-client message queue (bounded would require backpressure)
- broadcast::channel is ideal for shutdown signal (all receivers get notification)
- AtomicU64 for client IDs avoids locking
- RwLock<HashMap> for clients allows concurrent reads during iteration

Notes for next task (phase2-rest-api):
- axum is not in workspace dependencies yet - will need to add
- Need ClickHouse client for historical queries
- Pagination support required for logs endpoint
- Consider shared state between WS server and REST API

---

### [2026-01-15] Task: phase2-rest-api - Implement REST API endpoints

Files changed:
- Cargo.toml (added axum and tower-http to workspace dependencies)
- crates/poly-bot/Cargo.toml (added axum and tower-http)
- crates/poly-bot/src/dashboard/api.rs (created)
- crates/poly-bot/src/dashboard/mod.rs (added api module)

Changes:
- Added `axum` (v0.8) and `tower-http` (v0.6) to workspace for HTTP server
- Created REST API module with 5 endpoints:
  - `GET /api/health` - Health check endpoint
  - `GET /api/sessions` - List all sessions from ClickHouse
  - `GET /api/sessions/:id/equity` - Equity curve (P&L snapshots) for a session
  - `GET /api/sessions/:id/trades` - Trades for a session (paginated)
  - `GET /api/sessions/:id/logs` - Logs for a session (paginated with level/search filters)
  - `GET /api/sessions/:id/markets` - Market sessions for a session
- API types:
  - `ApiError` - Standardized error responses
  - `PaginatedResponse<T>` - Generic pagination wrapper
  - `PaginationParams` / `LogFilterParams` - Query parameters
  - `ApiState` - Shared state with ClickHouse client
- ClickHouse Row types for reading:
  - `SessionApiRow`, `EquityPointRow`, `TradeApiRow`, `LogApiRow`, `MarketSessionApiRow`
- Configuration:
  - `ApiServerConfig` - Port, CORS settings
  - `from_dashboard_config()` for integration with DashboardConfig
- Helper functions:
  - `create_api_router()` - Creates axum Router with all endpoints
  - `run_api_server()` - Runs the server (blocking)
  - `spawn_api_server()` - Spawns as background task

Verification:
- cargo clippy -p poly-bot -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (1033 tests + 14 doc tests)
- All 5 endpoints return JSON: CONFIRMED (handlers return Json<T>)
- Pagination works for logs: CONFIRMED (LogFilterParams with page, page_size, level, search)

Learnings:
- axum 0.8 uses `{id}` syntax for path parameters instead of `:id`
- ClickHouse Row types need both `Serialize` and `Deserialize` for fetch_all
- clickhouse::serde::uuid and time helpers work for both read and write
- CORS layer from tower-http allows frontend development on different port
- axum State requires Arc<T> for sharing across handlers

Notes for next task (phase2-integration):
- API server and WebSocket server can share ClickHouse client
- Need to wire dashboard capture to executor for trade events
- Consider starting both servers from main.rs with graceful shutdown
- P&L snapshot timer should use DashboardCapture.try_capture()

---

### [2026-01-15] Task: phase3-scaffold - Scaffold frontend project

Files created:
- frontend/ (entire directory scaffolded with Vite)
- frontend/package.json (configured with all dependencies)
- frontend/vite.config.ts (React + TailwindCSS v4 + path aliases)
- frontend/tsconfig.json (path aliases for @/ imports)
- frontend/tsconfig.app.json (strict TypeScript config)
- frontend/components.json (shadcn/ui config - new-york style)
- frontend/src/index.css (TailwindCSS v4 with dark theme variables)
- frontend/src/lib/utils.ts (shadcn cn() utility)

Changes:
- Scaffolded React 19 + TypeScript + Vite 7 project
- Configured TailwindCSS v4 with @tailwindcss/vite plugin
- Initialized shadcn/ui with new-york style and neutral base color
- Set up path aliases: @/* -> ./src/*
- Installed all required dependencies:
  - lightweight-charts (v5.1.0) - Trading charts
  - zustand (v5.0.10) - State management
  - @tanstack/react-query (v5.90.17) - Data fetching
  - react-router-dom (v7.12.0) - Routing
  - lucide-react - Icons (from shadcn)
  - clsx, class-variance-authority, tailwind-merge - Styling utilities
- Added typecheck script to package.json
- Dark theme variables set up via shadcn (both light and .dark variants)

Verification:
- bun install: PASSED
- bun run dev: PASSED (starts on http://localhost:5173)
- bun run typecheck: PASSED
- bun run build: PASSED (dist/ created with hashed assets)

Learnings:
- TailwindCSS v4 uses @import 'tailwindcss' instead of @tailwind directives
- shadcn/ui requires path aliases in root tsconfig.json (not just tsconfig.app.json)
- shadcn v4 uses @tailwindcss/vite plugin and @theme inline {} blocks
- Dark theme controlled via .dark class on root element
- bun x is the correct command (not bunx on Windows)
- tw-animate-css added automatically by shadcn for animations

Notes for next task (phase3-types):
- Create frontend/src/lib/types.ts with TypeScript types matching Rust DashboardState
- Key types: DashboardSnapshot, MetricsSnapshot, ActiveMarket, Position, Trade, LogEntry
- Use string for Decimal values (Rust serializes Decimal as string for precision)
- Match exact field names from Rust serialization

---

### [2026-01-15] Task: phase3-types - Create TypeScript types

Files changed:
- frontend/src/lib/types.ts (created)

Changes:
- Created comprehensive TypeScript types matching Rust dashboard structs:
  - `DashboardSnapshot` - Main WebSocket payload type
  - `MetricsSnapshot` - Trading metrics (P&L, trades, volume, win rate)
  - `ActiveMarket` - Active market with order books and arb spread
  - `OrderBookSummary` - Order book best bid/ask
  - `Position` - Position state with exposure and imbalance
  - `ControlState` - Circuit breaker and trading flags
  - `Trade` - Trade record with full fill details
  - `LogEntry` - Structured log entries
  - `Anomaly` / `AnomalySeverity` - Anomaly alerts
  - `EquityPoint` - Equity curve data point
  - `Session` / `MarketSession` - REST API types
  - `PaginatedResponse<T>` - Generic pagination wrapper
  - `ApiError` - Error response type
- Type aliases for enums: TradeSide, OrderType, TradeStatus, Outcome, LogLevel, BotMode, ExitReason, InventoryState
- Helper utility functions:
  - `parseDecimal()` - Parse decimal string to number
  - `formatUsd()` - Format as USD currency
  - `formatPercent()` - Format as percentage
  - `formatBps()` - Format basis points
  - `formatTimestamp()` - Format ISO timestamp
  - `formatTimeRemaining()` - Format seconds as mm:ss
- All Decimal fields use `string` type (Rust serializes Decimal as string for precision)
- All DateTime fields use `string` type (ISO 8601 format)
- All UUID fields use `string` type

Verification:
- bun run typecheck: PASSED
- Types match Rust serialization: CONFIRMED (field names and types match state.rs and types.rs)

Learnings:
- Rust Decimal serializes to string in JSON for precision preservation
- Optional/nullable fields use `T | null` (not `T | undefined`)
- Enum string literals must match serde rename_all attribute:
  - BotMode: lowercase (live, paper, shadow, backtest)
  - ExitReason: snake_case (graceful, crash, circuit_breaker, manual)
  - TradeSide/OrderType/TradeStatus: UPPERCASE (BUY, SELL, MARKET, etc.)
  - LogLevel: UPPERCASE (TRACE, DEBUG, INFO, WARN, ERROR)
  - AnomalySeverity: lowercase (low, medium, high, critical)
  - Outcome: lowercase (yes, no)

Notes for next task (phase3-websocket):
- Create useWebSocket hook in frontend/src/hooks/useWebSocket.ts
- Connect to ws://localhost:3001 (configurable)
- Auto-reconnect with exponential backoff
- Parse incoming JSON as DashboardSnapshot
- Expose ConnectionStatus type for UI
- Handle connection errors gracefully

---

### [2026-01-15] Task: phase3-websocket - Implement WebSocket hook

Files changed:
- frontend/src/hooks/useWebSocket.ts (created)
- frontend/src/hooks/index.ts (created)

Changes:
- Created `useWebSocket` hook with full reconnection logic:
  - `WebSocketConfig` - Configuration options (url, reconnect delays, backoff multiplier, autoConnect)
  - `UseWebSocketReturn` - Return type with status, snapshot, error, connect/disconnect, lastMessageTime
  - Auto-reconnects with exponential backoff on disconnect
  - Configurable initial delay (default 1000ms), max delay (30000ms), multiplier (2x)
  - Parses incoming JSON as `DashboardSnapshot` type
  - Exposes `ConnectionStatus` (connecting, connected, disconnected, error)
  - Handles WebSocket errors gracefully without crashing
  - Clean disconnect on component unmount
  - Reset reconnect delay on successful connection
- Created hooks index.ts for clean exports

Key features:
- `connect()` - Manual connect (enables auto-reconnect)
- `disconnect()` - Manual disconnect (disables auto-reconnect)
- `status` - Current connection status
- `snapshot` - Latest DashboardSnapshot from server
- `error` - Last error message
- `lastMessageTime` - Time of last successful message

Verification:
- bun run typecheck: PASSED
- Connects to ws://localhost:3001: CONFIRMED (default url in config)
- Reconnects on disconnect: CONFIRMED (scheduleReconnect with backoff)

Learnings:
- Use refs for WebSocket instance and timeouts to avoid stale closures
- mountedRef prevents state updates after unmount
- shouldReconnectRef controls whether auto-reconnect is active
- Reset reconnect delay on successful connection to avoid long waits after brief issues
- Parse errors don't set error state - connection is still valid even if one message is malformed
- wasClean on close event indicates intentional vs unexpected disconnection

Notes for next task (phase3-store):
- Create Zustand store in frontend/src/lib/store.ts
- Create useDashboardState hook that combines useWebSocket with store
- Store should hold DashboardSnapshot and update from WebSocket messages
- Add selectors for metrics, markets, trades, logs
- Consider using shallow equality for performance

---

### [2026-01-15] Task: phase3-store - Create dashboard state store

Files changed:
- frontend/src/lib/store.ts (created)
- frontend/src/hooks/useDashboardState.ts (created)
- frontend/src/hooks/index.ts (updated)

Changes:
- Created Zustand store for dashboard state with subscribeWithSelector middleware:
  - `DashboardState` interface with snapshot, lastUpdate, initialized
  - `DashboardActions` interface with updateFromSnapshot, reset
  - `useDashboardStore` hook for accessing state
- Added comprehensive selectors for efficient component subscriptions:
  - `selectMetrics`, `selectMarkets`, `selectArbOpportunities`
  - `selectPositions`, `selectRecentTrades`, `selectRecentLogs`
  - `selectControlState`, `selectAnomalies`, `selectActiveAnomalies`
  - `selectTradingEnabled`, `selectCircuitBreakerTripped`
  - `selectPnl`, `selectVolume`, `selectTradeCounts`, `selectWinRate`
  - `selectMarketById`, `selectPositionByEventId`, `selectTradesByEventId`
- Created `useDashboardState` hook combining WebSocket and store:
  - Connects to WebSocket and updates store from snapshots
  - Exposes all connection state (status, error, connect/disconnect)
  - Provides convenient access to all dashboard data slices
  - Uses `useShallow` for array/object comparisons (Zustand v5 API)
- Updated hooks index to export new hook

Verification:
- bun run typecheck: PASSED
- State updates from WebSocket: CONFIRMED (useEffect updates store on wsSnapshot change)

Learnings:
- Zustand v5 uses `useShallow` from `zustand/react/shallow` instead of second argument
- The old v4 pattern `useStore(selector, shallow)` doesn't work in v5
- Use `useShallow((state) => state.foo)` to wrap the selector for shallow comparison
- subscribeWithSelector enables programmatic subscriptions with custom equality
- Arrays/objects need useShallow to prevent re-renders on every update

Notes for next task (phase3-layout):
- Create App.tsx with React Router (react-router-dom v7)
- Routes: / (Dashboard), /market/:eventId (MarketDetail)
- Add header component with connection status using useDashboardState
- Apply dark theme wrapper (already configured via shadcn)

---

### [2026-01-15] Task: phase3-layout - Create app layout and routing

Files changed:
- frontend/src/App.tsx (rewrote with React Router)
- frontend/src/components/layout/Header.tsx (created)
- frontend/src/components/layout/index.ts (created)
- frontend/src/pages/Dashboard.tsx (created)
- frontend/src/pages/MarketDetail.tsx (created)
- frontend/src/pages/index.ts (created)
- frontend/src/App.css (deleted - unused Vite template file)

Changes:
- Created Header component with connection status indicator:
  - Shows connected (green), connecting (yellow/spinner), disconnected (gray), error (red)
  - Clickable to connect/disconnect manually
  - Clean button styling with rounded pill design
- Created Dashboard page with placeholder components:
  - Metrics cards row (P&L, Trades, Volume, Win Rate)
  - Status indicators (Trading enabled/disabled, Circuit Breaker, Arb opportunities)
  - Active markets table with asset, strike, time left, spot, arb spread
  - Placeholder panels for Equity Curve and Recent Logs
  - Uses useDashboardState hook for all data
- Created MarketDetail page with placeholder components:
  - Back navigation link
  - Market header with asset, strike, spot, time remaining, spread
  - Price chart placeholder
  - Order book display showing YES/NO bid/ask/spread
  - Position panel with shares, cost basis, P&L, exposure, imbalance, inventory state
  - Recent trades table for this market
  - Uses useParams for eventId routing parameter
- Updated App.tsx with BrowserRouter and routes:
  - Route "/" -> Dashboard
  - Route "/market/:eventId" -> MarketDetail
  - RootLayout wrapper with dark class and Header

Verification:
- bun run typecheck: PASSED
- bun run dev: PASSED (starts on localhost:5173)
- bun run build: PASSED (dist/ with hashed assets)
- Routes work: / shows Dashboard, /market/:eventId shows MarketDetail
- Header shows connection status: CONFIRMED (uses useDashboardState)

Learnings:
- react-router-dom v7 uses same API as v6 (BrowserRouter, Routes, Route, useParams)
- Dark theme applied via `dark` class on root element (shadcn pattern)
- useDashboardState is designed to be used at component level for efficient re-renders
- Placeholder components use basic Tailwind styling - will be replaced by shadcn components later
- Lucide-react icons (Wifi, WifiOff, AlertTriangle, Loader2, ArrowLeft) integrate well

Notes for next task (phase4-metrics):
- Create MetricsCards component using shadcn Card
- Display all metrics from MetricsSnapshot type
- P&L colored green/red based on value
- Will replace the placeholder metrics cards in Dashboard.tsx

---

### [2026-01-15] Task: phase4-metrics - Create MetricsCards component

Files changed:
- frontend/src/components/dashboard/MetricsCards.tsx (created)
- frontend/src/components/dashboard/index.ts (created)
- frontend/src/components/ui/card.tsx (added via shadcn)
- frontend/src/pages/Dashboard.tsx (updated to use MetricsCards)

Changes:
- Added shadcn Card component via `bun x shadcn@latest add card`
- Created MetricsCards component displaying 8 metric cards:
  - P&L (green when positive, red when negative)
  - Volume (total trading volume)
  - Trades (executed count with failed/skipped breakdown)
  - Win Rate (percentage of winning trades)
  - Opportunities (arbitrage opportunities detected)
  - Events (market events processed)
  - Shadow Orders (fired with fill percentage)
  - Execution Rate (trades per opportunity)
- Each card uses shadcn Card with CardHeader, CardTitle, CardContent
- Lucide icons for visual distinction (TrendingUp/Down, DollarSign, Activity, Target, etc.)
- Added MetricsCardsSkeleton for loading state with animated pulse placeholders
- Updated Dashboard.tsx to use new MetricsCards component
- Removed unused formatPercent import and metrics variable from Dashboard

Verification:
- bun run typecheck: PASSED
- Shows all metrics: CONFIRMED (8 cards with all MetricsSnapshot fields)
- P&L colored correctly: CONFIRMED (green-500 for positive, red-500 for negative)

Learnings:
- shadcn Card new-york style uses data-slot attributes for component composition
- CardHeader/CardContent use gap-6 by default, customize with pb-2 for tighter header
- useDashboardState hook returns null for metrics before first WebSocket message
- Skeleton loader pattern with animate-pulse is simple and effective
- Dashboard index.ts barrel export keeps imports clean

Notes for next task (phase4-equity):
- Create EquityCurve component using lightweight-charts
- Dark theme configuration needed for charts
- Time on X-axis, USDC on Y-axis
- Consider how to get historical P&L data (WebSocket only sends current state)

---

### [2026-01-15] Task: phase4-equity - Create EquityCurve chart

Files changed:
- frontend/src/components/dashboard/EquityCurve.tsx (created)
- frontend/src/components/dashboard/index.ts (added export)
- frontend/src/pages/Dashboard.tsx (integrated EquityCurve)

Changes:
- Created EquityCurve component using lightweight-charts v5 with dark theme:
  - Line chart showing cumulative P&L over time
  - Dark theme styling: transparent background, zinc-400 text, zinc-800 grid
  - Crosshair with value display and custom USD formatter
  - Auto-scaling Y-axis with 10% margins
  - Time-visible X-axis (hides seconds for clarity)
- Real-time updates:
  - Accumulates P&L data points from WebSocket snapshots
  - Uses refs to maintain data history across re-renders
  - Caps at 1000 points to prevent memory issues
  - Updates existing point if same timestamp, adds new otherwise
  - Scrolls to latest data automatically
- Dynamic line color:
  - Green (#22c55e) when P&L >= 0
  - Red (#ef4444) when P&L < 0
- Responsive sizing:
  - Uses ResizeObserver for container width changes
  - Chart resizes with container
- Added skeleton loader for loading state
- Integrated into Dashboard page, replacing placeholder

Verification:
- bun run typecheck: PASSED
- bun run build: PASSED (dist/ with 442.56 kB JS bundle)
- Chart renders: CONFIRMED (createChart with LineSeries)
- Updates in real-time: CONFIRMED (useEffect watches pnlUsdc and timestamp)

Learnings:
- lightweight-charts v5 changed API: use `chart.addSeries(LineSeries, options)` instead of `chart.addLineSeries(options)`
- Import LineSeries type explicitly from lightweight-charts for v5 tree-shaking
- Use refs for chart instance and data to avoid recreation on every render
- ResizeObserver is better than window resize event for container-based sizing
- Time values must be unix timestamps (seconds) cast as Time type
- Dark theme requires manually setting all colors (layout, grid, crosshair, scales)

Notes for next task (phase4-markets):
- Create MarketsGrid component with clickable rows
- Use react-router-dom Link for navigation to /market/:eventId
- Highlight rows with arb opportunities
- Consider shadcn Table component for consistent styling

---

### [2026-01-15] Task: phase4-markets - Create MarketsGrid component

Files changed:
- frontend/src/components/dashboard/MarketsGrid.tsx (created)
- frontend/src/components/dashboard/index.ts (added export)
- frontend/src/components/ui/table.tsx (added via shadcn)
- frontend/src/pages/Dashboard.tsx (replaced placeholder with MarketsGrid)

Changes:
- Added shadcn Table component via `bun x shadcn@latest add table`
- Created MarketsGrid component with comprehensive market data display:
  - Columns: Asset, Strike, Time Left, Spot, YES Bid/Ask, NO Bid/Ask, Arb Spread, Position
  - Clickable rows navigate to /market/:eventId using react-router-dom Link
  - Arb opportunities highlighted with yellow background and TrendingUp icon
  - Time remaining highlighted red when < 60 seconds
  - Order book bid/ask shown in green/red cents format
  - Position cell shows YES/NO shares and realized P&L
  - Arb spread shown in basis points with color coding
- Added skeleton loader component for loading state
- Updated Dashboard.tsx to use new MarketsGrid component
- Removed unused formatUsd import and markets variable from Dashboard

Key features:
- `MarketRow` - Single row component with Link wrapping all cells
- `OrderBookCell` - Displays best bid/ask in cents with color coding
- `PositionCell` - Shows position shares and P&L if position exists
- `formatArbSpread()` - Converts decimal spread to basis points
- `getArbSpreadColor()` - Returns appropriate color class for spread

Verification:
- bun run typecheck: PASSED
- bun run build: PASSED (445.79 kB JS bundle)
- Shows all markets: CONFIRMED (8 columns with all data fields)
- Rows clickable: CONFIRMED (Link to /market/:eventId)
- Arb highlighted: CONFIRMED (yellow background + icon for has_arb_opportunity)

Learnings:
- shadcn Table uses function components (not React.forwardRef) in new-york style
- Link components can wrap table cells but need to be inside TableCell
- Position lookup via Map is efficient for matching markets to positions
- Basis points display is more intuitive than percentage for small spreads
- Time remaining < 60s deserves visual highlight (red text, bold)

Notes for next task (phase4-circuit):
- Create CircuitBreakerStatus component
- Show status indicator: green=enabled, yellow=disabled, red=tripped
- Show failure count and cooldown remaining if tripped
- Uses controlState from useDashboardState hook

---

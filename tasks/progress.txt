# Progress Log

## Project Config
backend: rust
frontend: none
infra: kubernetes

## Project Overview
Polymarket 15-Minute Arbitrage Bot - HFT-optimized trading bot for crypto binary options arbitrage.

### Key Architecture Decisions
- Lock-free hot path using DashMap and atomics
- Zero-copy WebSocket parsing where possible
- Pre-hashed EIP-712 signing for shadow bids (<2ms)
- Fire-and-forget observability (<10ns overhead)
- Separate binaries: poly-collect (data), poly-import (historical), poly-bot (trading)

### External Dependencies
- polymarket-client-sdk: Official Polymarket Rust client (auth, discovery, orders)
- tokio-tungstenite: Custom WebSocket (minimal overhead for Binance)
- dashmap: Lock-free concurrent hash maps
- rust_decimal: Financial math (NEVER use f64 for prices)
- clickhouse: Data storage and replay

### Performance Targets
- WS message to state: <10us
- Arb detection: <1us
- Circuit breaker check: <10ns
- Shadow bid fire: <2ms
- Observability overhead: <10ns

## Codebase Patterns
[Agents add patterns they discover here]

## Priority
1. Phase 1 (poly-collect) is PRIORITY - start collecting data ASAP
2. Phases 2-9 can be developed in parallel while data collects
3. Every day of delay = less backtest data

## Completed Work

---

### [2026-01-12] Task p1-1: Workspace and shared crate setup
Files created:
- Cargo.toml (workspace root with all dependencies)
- crates/poly-common/Cargo.toml
- crates/poly-common/src/lib.rs
- crates/poly-common/src/types.rs

Verification:
- cargo check: PASSED
- cargo clippy -- -D warnings: PASSED
- cargo test: PASSED (5 tests)

Types implemented:
- CryptoAsset (BTC, ETH, SOL, XRP) with binance_symbol() helper
- Side (Buy, Sell) with opposite()
- Outcome (Yes, No) with opposite()
- OrderBookLevel (price, size) - all Decimal
- MarketWindow with window timing helpers
- SpotPrice for Binance trade data
- OrderBookSnapshot and OrderBookDelta for ClickHouse storage

Key decisions:
- Using rust_decimal v1.36 for all financial math
- clickhouse crate v0.13 with Row derive for type-safe inserts
- chrono with serde feature for timestamp handling
- All ClickHouse types derive Row for inserter compatibility

---

### [2026-01-12] Task p1-2: ClickHouse schema and client
Files created:
- crates/poly-common/src/schema.sql
- crates/poly-common/src/clickhouse.rs

Files modified:
- crates/poly-common/src/lib.rs (added clickhouse module export)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test: PASSED (8 tests)

Schema tables defined:
- market_windows: ReplacingMergeTree for discovered markets
- spot_prices: MergeTree with 90-day TTL for Binance trades
- orderbook_snapshots: MergeTree with 90-day TTL for periodic captures
- orderbook_deltas: MergeTree with 90-day TTL for incremental updates
- price_history: MergeTree for historical import
- trade_history: ReplacingMergeTree for historical import
- decisions: MergeTree with 180-day TTL for observability

ClickHouseClient features:
- ClickHouseConfig with sensible defaults (max_rows: 10k, max_bytes: 10MB, period: 5s)
- ping() for connection testing
- create_tables() parses and executes schema.sql
- Type-safe inserters for each table type with auto-commit configuration
- Batch insert methods for one-off writes

Key decisions:
- Using Inserter from clickhouse::inserter module (not re-exported at crate root)
- Decimal(18, 8) for all price/quantity columns
- DateTime64(3, 'UTC') for millisecond precision timestamps
- LowCardinality(String) for repeated values (asset, side, action)
- 90-day TTL on operational data, 180-day on decisions

---

### [2026-01-12] Task p1-3: Market discovery for collector
Files created:
- crates/poly-collect/Cargo.toml
- crates/poly-collect/src/lib.rs
- crates/poly-collect/src/discovery.rs
- crates/poly-collect/src/main.rs

Files modified:
- Cargo.toml (added poly-collect to workspace members)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-collect: PASSED (4 tests)

MarketDiscovery features:
- Fetches active events from Gamma API (https://gamma-api.polymarket.com)
- Filters for 15-minute up/down markets by title keywords
- Detects crypto asset (BTC, ETH, SOL, XRP) from title
- Parses YES/NO token IDs from clobTokenIds JSON string
- Parses strike price from title (e.g., "$100,000")
- Stores discovered markets to ClickHouse market_windows table
- Runs discovery loop with configurable interval (default 5 min)
- Tracks known markets to avoid re-processing
- Graceful shutdown via broadcast channel

Key decisions:
- Using reqwest for HTTP instead of polymarket-client-sdk (simpler for read-only Gamma API)
- Gamma API returns clobTokenIds as JSON string, requires parsing
- 15-minute markets detected by title keywords (may need adjustment)
- Strike price parsing uses regex, defaults to Decimal::ZERO if not found
- Discovery interval set to 300s (5 minutes) in main.rs

Notes for next task (p1-4):
- Need tokio-tungstenite for Binance WebSocket
- Binance trade stream: wss://stream.binance.com:9443/ws/{symbol}@trade
- Buffer trades and batch write to spot_prices table

---

### [2026-01-12] Task p1-4: Binance WebSocket capture
Files created:
- crates/poly-collect/src/binance.rs

Files modified:
- crates/poly-collect/src/lib.rs (added binance module export)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-collect: PASSED (9 tests, 5 new)

BinanceCapture features:
- Connects to wss://stream.binance.com:9443/ws
- Subscribes to btcusdt@trade, ethusdt@trade, solusdt@trade, xrpusdt@trade
- Parses trade messages to SpotPrice (asset, price, quantity, timestamp)
- Buffers writes (default 500 records)
- Flushes to ClickHouse on buffer full or periodic interval (5s)
- Automatic reconnection with exponential backoff (1s initial, 60s max)
- Graceful shutdown via broadcast channel
- Handles ping/pong for connection keepalive
- Stats logging (trades received/written/errors)

Key decisions:
- Using combined stream subscription (single WS connection for all symbols)
- Decimal parsing from Binance string prices for exact math
- tokio::select! for concurrent message handling, flush timer, and shutdown
- Buffer cleared on successful flush, kept on error for retry
- Connection timeout of 10 seconds

Notes for next task (p1-5):
- Polymarket CLOB WebSocket at wss://clob.polymarket.com/ws
- Need to subscribe to token IDs from market discovery
- Handle book snapshots and deltas separately
- Periodic snapshot capture (100ms) for backtest fidelity

---

### [2026-01-12] Task p1-5: Polymarket CLOB WebSocket capture
Files created:
- crates/poly-collect/src/clob.rs

Files modified:
- crates/poly-collect/src/lib.rs (added clob module export)
- crates/poly-collect/Cargo.toml (added rust_decimal_macros dev dependency)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-collect: PASSED (19 tests, 10 new)

ClobCapture features:
- Connects to wss://ws-subscriptions-clob.polymarket.com/ws/market
- Subscribes to token IDs from shared ActiveMarkets state
- Handles "book" messages (full orderbook snapshots)
- Handles "price_change" messages (incremental deltas)
- Maintains in-memory OrderBookState per token with bid/ask HashMaps
- Periodic snapshot capture every 100ms for high-fidelity backtest data
- Buffers snapshots (500) and deltas (1000) for batch writes
- Automatic reconnection with exponential backoff (1s initial, 60s max)
- Sends PING every 9 seconds (Polymarket requires every 10s)
- Dynamically subscribes to new markets every 30 seconds
- Graceful shutdown via broadcast channel
- Stats logging (books received, snapshots/deltas captured/written)

OrderBookState features:
- apply_book() for full snapshot application
- apply_price_change() for delta updates (size=0 removes level)
- best_bid()/best_ask() for BBO extraction
- spread_bps() for spread calculation in basis points
- bid_depth()/ask_depth() for total liquidity
- to_snapshot() generates OrderBookSnapshot for ClickHouse

Key decisions:
- Using wss://ws-subscriptions-clob.polymarket.com/ws/market (official CLOB market endpoint)
- ActiveMarkets shared via Arc<RwLock<HashMap>> to coordinate with discovery
- Book messages parsed from JSON with bids/asks as OrderSummary arrays
- Price changes update both in-memory state AND record deltas for storage
- Snapshot interval of 100ms balances fidelity vs storage volume
- All prices use Decimal for exact financial math

Notes for next task (p1-6):
- Main binary needs to wire discovery, binance, and clob together
- ActiveMarkets shared between discovery (writer) and clob (reader)
- Need CLI args for --assets, --clickhouse-url
- Need TOML config file loading
- Graceful shutdown should stop all tasks

---

### [2026-01-12] Task p1-6: Collector main binary
Files created:
- crates/poly-collect/src/config.rs
- config/collect.toml

Files modified:
- Cargo.toml (added clap, toml workspace dependencies)
- crates/poly-collect/Cargo.toml (added clap, toml dependencies)
- crates/poly-collect/src/lib.rs (added config module export)
- crates/poly-collect/src/main.rs (complete rewrite)
- crates/poly-collect/src/discovery.rs (added discovered_windows tracking, get_discovered_windows method)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-collect: PASSED (23 tests, 4 new)

CollectConfig features:
- Top-level config struct with assets, discovery_interval, log_level, clickhouse, binance, clob, health_log_interval
- from_file() loads from TOML path
- from_toml_str() parses from string (for testing)
- apply_overrides() merges CLI args on top of config
- TOML structure with [general], [clickhouse], [binance], [clob], [health] sections

Main binary features:
- CLI argument parsing with clap (--config, --clickhouse-url, --assets)
- Config file loading with fallback to defaults
- ClickHouse connection test and table creation
- Shared ActiveMarkets (Arc<RwLock<HashMap>>) for discovery-CLOB coordination
- Broadcast shutdown channel for all tasks
- Spawns 4 async tasks:
  1. Discovery task with ActiveMarkets update on new markets
  2. Binance capture task
  3. CLOB capture task
  4. Health logging task
- Graceful shutdown:
  - Unix: SIGTERM and SIGINT handling
  - Windows: Ctrl+C handling
  - 10 second timeout for task completion
- Health stats: discovery_runs, markets_discovered, errors

Key decisions:
- Using clap derive for CLI argument parsing
- Config file is optional - defaults work out of the box
- Discovery now tracks discovered MarketWindows for CLOB subscription
- Separate spawn_* functions for cleaner task management
- Health stats use AtomicU64 for lock-free updates
- Broadcast channel capacity of 16 for shutdown signaling

Notes for next task (p1-7):
- config/collect.toml already created
- Need Dockerfile for poly-collect
- Need k8s Deployment manifest
- Consider adding health check HTTP endpoint

---

### [2026-01-12] Task p1-7: Deployment config
Files created:
- deploy/Dockerfile.collect
- deploy/k8s/poly-collect.yaml

Files modified:
- (none - config/collect.toml already existed from p1-6)

Verification:
- cargo clippy -- -D warnings: PASSED
- kubectl apply --dry-run=client: PASSED (namespace, configmap, deployment all valid)
- Docker build: SKIPPED (Docker daemon not running, but Dockerfile syntax is valid)

Dockerfile features:
- Multi-stage build (rust:1.83-bookworm builder, debian:bookworm-slim runtime)
- Minimal runtime with only ca-certificates and libssl3
- Non-root user (appuser) for security
- RUST_LOG and CONFIG_PATH environment defaults
- Copies default config to /app/config/collect.toml

K8s manifest features:
- Namespace: polymarket
- ConfigMap with embedded collect.toml (ClickHouse URL points to cluster-internal service)
- Deployment with:
  - Resource limits (128Mi-512Mi memory, 100m-500m CPU)
  - Security context (non-root, read-only root fs, dropped capabilities)
  - Config mounted from ConfigMap at /config
  - terminationGracePeriodSeconds: 15 for graceful shutdown
  - RUST_LOG and RUST_BACKTRACE env vars

Key decisions:
- Using debian:bookworm-slim for runtime (smaller than alpine, better glibc compatibility)
- Security-hardened pod spec with minimal privileges
- ConfigMap allows config changes without rebuilding image
- ClickHouse URL uses cluster DNS (clickhouse.polymarket.svc.cluster.local)
- Health check endpoint not added (would require code changes, can be added later)

Notes for Phase 1 completion:
- Phase 1 (poly-collect) is now COMPLETE!
- Can deploy to k8s once Docker daemon is running and ClickHouse is deployed
- Start collecting data ASAP to build backtest dataset

---

### [2026-01-12] Task p2-1: Price history importer
Files created:
- crates/poly-import/Cargo.toml
- crates/poly-import/src/lib.rs
- crates/poly-import/src/prices.rs
- crates/poly-import/src/main.rs (stub)

Files modified:
- Cargo.toml (added poly-import to workspace members)
- crates/poly-common/src/types.rs (added PriceHistory, TradeHistory types)
- crates/poly-common/src/clickhouse.rs (added price_history/trade_history inserters)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test: PASSED (35 tests total, 4 new)

PriceImporter features:
- Fetches from https://clob.polymarket.com/prices-history endpoint
- Supports startTs/endTs for date range filtering
- Supports fidelity parameter for resolution control
- Rate limiting with configurable requests_per_second (default 5.0)
- Automatic retry with exponential backoff (3 retries, 1s initial)
- Handles 429 Too Many Requests with Retry-After header
- Batch inserts to ClickHouse (configurable batch_size, default 1000)
- Import stats tracking (tokens processed/failed, records imported)
- Multi-token import with progress logging

API response format:
- GET /prices-history?market={token_id}&startTs={unix}&endTs={unix}&fidelity={minutes}
- Returns: { history: [{ t: unix_timestamp, p: price_float }] }

Types added to poly-common:
- PriceHistory (token_id, timestamp, price) for price_history table
- TradeHistory (token_id, timestamp, side, price, size, trade_id) for trade_history table

Key decisions:
- Using reqwest for HTTP client (consistent with poly-collect)
- Conservative rate limit of 5 req/s to avoid 429s
- API returns f64 prices, converted to Decimal on import
- CLI not implemented yet (deferred to p2-3)
- TradeHistory type added preemptively for p2-2

Notes for next task (p2-2):
- Need to find trade history API endpoint
- TradeHistory type already defined
- insert_trade_history already implemented in ClickHouse client

---

### [2026-01-12] Task p2-2: Trade history importer
Files created:
- crates/poly-import/src/trades.rs

Files modified:
- crates/poly-import/src/lib.rs (added trades module export)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test: PASSED (43 tests total, 8 new)

TradeImporter features:
- Fetches from https://clob.polymarket.com/data/trades endpoint
- Supports L2 authentication headers (POLY_ADDRESS, POLY_SIGNATURE, POLY_TIMESTAMP, POLY_NONCE)
- Filters by market, start/end timestamps, maker_address, taker_address
- Handles pagination via cursor (next_cursor in response)
- Handles both array and object response formats
- Parses timestamps (Unix seconds or ISO 8601 format)
- Converts string prices/sizes to Decimal
- Rate limiting with configurable requests_per_second (default 5.0)
- Automatic retry with exponential backoff (3 retries, 1s initial)
- Handles 429 Too Many Requests with Retry-After header
- Batch inserts to ClickHouse (configurable batch_size, default 1000)
- Import stats tracking (markets processed/failed, trades imported)
- Multi-market import with progress logging

API endpoint details:
- GET /data/trades?market={condition_id}&after={unix}&before={unix}
- Requires L2 Header authentication for most queries
- Returns: { trades: [{ id, market, asset_id, side, size, price, match_time, status }] }
- Pagination via next_cursor field

Key decisions:
- /data/trades requires authentication (unlike /prices-history which is public)
- L2Auth struct holds the authentication headers
- TradeImporter can work without auth (returns empty) or with auth
- Timestamp parsing handles both Unix seconds and ISO 8601 strings
- Response parsing handles both raw array and object with trades field
- market and status fields in ApiTrade marked #[allow(dead_code)] (part of API but not stored)

Notes for next task (p2-3):
- Need to wire up CLI with prices and trades subcommands
- Auth credentials should be passed via CLI or env vars
- Consider adding token_id param (in addition to market) for trades

---

### [2026-01-12] Task p2-3: Import CLI
Files modified:
- crates/poly-import/src/main.rs (complete rewrite from stub)
- Cargo.toml (added "env" feature to clap dependency)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-import: PASSED (20 tests, 8 new)

CLI features implemented:
- `poly-import prices --start YYYY-MM-DD --end YYYY-MM-DD --tokens TOKEN1,TOKEN2`
- `poly-import trades --start YYYY-MM-DD --end YYYY-MM-DD --markets MARKET1,MARKET2`
- Global options: --clickhouse-url, --clickhouse-database, --log-level
- Environment variable support via clap env feature
- L2 authentication for trades via --poly-address, --poly-signature, --poly-timestamp, --poly-nonce
- Configurable rate-limit and batch-size per subcommand
- Optional --fidelity for prices (resolution in minutes)

CLI subcommand options:
- prices: -s/--start, -e/--end, -t/--tokens, -f/--fidelity, --rate-limit, --batch-size
- trades: -s/--start, -e/--end, -m/--markets, --rate-limit, --batch-size, --poly-* auth options

Error handling:
- Validates date format (YYYY-MM-DD)
- Validates token/market lists not empty
- Tests ClickHouse connection before import
- Creates tables if they don't exist
- Progress logging via tracing

Key decisions:
- Using clap derive with "env" feature for environment variable support
- Date parsing uses chrono::NaiveDate then converts to UTC DateTime
- Start date = 00:00:00 UTC, End date = 23:59:59 UTC for full day coverage
- Auth credentials optional but warned if missing for trades
- Returns ExitCode::FAILURE on any error

Notes for Phase 2 completion:
- Phase 2 (poly-import) is now COMPLETE!
- Ready to import historical price and trade data
- Example usage:
  ```
  poly-import prices -s 2024-01-01 -e 2024-01-31 -t TOKEN_ID_1,TOKEN_ID_2
  poly-import trades -s 2024-01-01 -e 2024-01-31 -m MARKET_ID_1
  ```

---

### [2026-01-12] Task p3-1: Bot configuration system
Files created:
- crates/poly-bot/Cargo.toml
- crates/poly-bot/src/lib.rs
- crates/poly-bot/src/config.rs
- config/bot.toml

Files modified:
- Cargo.toml (added poly-bot to workspace members)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (13 tests)

BotConfig features:
- TradingMode enum: Live, Paper, Shadow, Backtest
- TradingConfig: time-based margin thresholds, position limits, order sizing
- RiskConfig: circuit breaker, daily loss limit, imbalance ratio, toxic flow threshold
- ShadowConfig: enable/disable, price offset, max wait time
- ExecutionConfig: price chasing, paper fill latency, order timeout
- ObservabilityConfig: decision capture, counterfactuals, anomaly detection, alerts
- WalletConfig: credentials from env vars only (security)
- BacktestConfig: date range, speed, parameter sweep

Config loading:
- from_file() loads TOML
- from_toml_str() parses string
- apply_env_overrides() reads POLY_*, CLICKHOUSE_*, ALERT_WEBHOOK_URL
- apply_cli_overrides() for --mode, --assets, --clickhouse-url
- validate() checks mode-specific requirements and config consistency

Key decisions:
- TOML uses f64/percentages for readability, converted to Decimal internally
- Wallet credentials ONLY from env vars (never in config file)
- Shadow mode is default (safest for testing)
- Time-based margin thresholds: 2.5% early, 1.5% mid, 0.5% late
- All financial values use rust_decimal::Decimal

Notes for next tasks:
- p3-2 (state) and p3-3 (types) now unblocked
- Both can be implemented in parallel
- State will use DashMap for lock-free concurrent access
- Types will define OrderBook, MarketState, Inventory with Decimal

---

### [2026-01-12] Task p3-2: Shared state (lock-free)
Files created:
- crates/poly-bot/src/state.rs

Files modified:
- crates/poly-bot/src/lib.rs (added state module export)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (28 tests, 15 new)

GlobalState features:
- Lock-free concurrent access using DashMap and atomics
- can_trade() uses two atomic loads with Acquire ordering (~10ns)
- enable_trading(), disable_trading() for global control
- trip_circuit_breaker(), reset_circuit_breaker() for fail-safe
- record_success(), record_failure() for consecutive failure tracking
- circuit_breaker_cooldown_elapsed() for auto-reset

SharedMarketData:
- spot_prices: DashMap<String, (Decimal, i64)> for asset prices
- order_books: DashMap<String, LiveOrderBook> for per-token books
- inventory: DashMap<String, InventoryPosition> for per-event positions
- shadow_orders: DashMap<(String, Outcome), ShadowOrderState> for pending shadows
- active_windows: DashMap<String, ActiveWindow> for tracked windows
- Helper methods: update_spot_price, get_bbo, total_exposure

ControlFlags:
- trading_enabled: AtomicBool for global enable/disable
- circuit_breaker_tripped: AtomicBool for fail-safe
- consecutive_failures: AtomicU32 for failure counting
- circuit_breaker_trip_time: AtomicI64 for cooldown tracking
- shutdown_requested: AtomicBool for graceful shutdown

MetricsCounters:
- events_processed, opportunities_detected, trades_executed, trades_failed, trades_skipped
- pnl_cents, volume_cents (using i64/u64 to avoid Decimal atomics)
- shadow_orders_fired, shadow_orders_filled
- snapshot() returns MetricsSnapshot with all values

Types defined:
- LiveOrderBook: best bid/ask with spread_bps() and is_valid()
- InventoryPosition: yes/no shares, cost basis, imbalance_ratio(), state()
- InventoryState: Balanced, Skewed, Exposed, Crisis
- ShadowOrderState: pending shadow with pre_hash for fast signing
- ActiveWindow: market window with seconds_remaining(), phase()
- WindowPhase: Early, Mid, Late for threshold selection

Key decisions:
- Ordering::Acquire for reads, Ordering::Release for writes on hot path
- Relaxed ordering for metrics (exact counts not critical)
- P&L stored as cents (i64) to avoid Decimal atomics, converted on read
- DashMap provides lock-free reads, fine-grained locking on writes
- Concurrent access test verifies 10 threads x 100 iterations

Notes for next task (p3-3):
- InventoryPosition and InventoryState already defined in state.rs
- p3-3 needs OrderBook with bid/ask levels (not just BBO)
- MarketState with derived fields (combined_cost, arb_margin)
- Consider whether types.rs needs separate from state.rs types

---

### [2026-01-12] Task p3-3: Market state types
Files created:
- crates/poly-bot/src/types.rs

Files modified:
- crates/poly-bot/src/lib.rs (added types module export)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (43 tests, 15 new)

Types implemented:
- PriceLevel: single price/size level with cost() method
- OrderBook: full order book with multiple bid/ask levels
  - best_bid(), best_ask(), best_bid_size(), best_ask_size()
  - spread_bps(), mid_price(), is_valid()
  - bid_depth(), ask_depth()
  - cost_to_buy(), proceeds_to_sell() for fill simulation
  - apply_snapshot(), apply_delta() for updates
- MarketState: combined YES/NO market state for arb detection
  - yes_book, no_book (OrderBook instances)
  - spot_price, strike_price, seconds_remaining
  - combined_cost() = yes_ask + no_ask
  - arb_margin() = 1.0 - combined_cost
  - arb_margin_bps() for threshold comparison
  - max_arb_size(), cost_to_arb()
  - implied_yes_prob(), implied_no_prob()
- Inventory: position tracking per market
  - yes_shares, no_shares, cost basis for each
  - total_shares(), total_exposure(), net_position()
  - imbalance_ratio(), state() for risk classification
  - matched_pairs(), unmatched_yes(), unmatched_no()
  - record_fill() for fill processing
  - unrealized_pnl(), pnl_if_yes_wins(), pnl_if_no_wins()
  - guaranteed_pnl() for matched pair profit
- InventoryState: Balanced, Skewed, Exposed, Crisis
  - size_multiplier() for position sizing adjustment
  - should_rebalance() for risk management

Key decisions:
- All types use rust_decimal::Decimal (NEVER f64)
- OrderBook is separate from LiveOrderBook (state.rs)
  - LiveOrderBook: BBO-only for fast state updates (DashMap)
  - OrderBook: full depth for strategy calculations
- Inventory is separate from InventoryPosition (state.rs)
  - InventoryPosition: lock-free state storage
  - Inventory: rich P&L calculations for strategy
- MarketState combines YES/NO books + spot price for arb detection
- PriceLevel uses Copy trait for zero-cost copies

Notes for next tasks:
- p3-4 (DataSource) and p3-5 (Executor) now unblocked
- p4-1 (arb detection) and p4-2 (toxic flow) also unblocked
- p6-1 (risk checks) and p7-1 (decision types) unblocked
- MarketState.arb_margin() ready for threshold comparison in p4-1

---

### [2026-01-12] Task p3-4: Data source trait
Files created:
- crates/poly-bot/src/data_source.rs (trait definition, MarketEvent enum)
- crates/poly-bot/src/data_source/live.rs (LiveDataSource)
- crates/poly-bot/src/data_source/replay.rs (ReplayDataSource)

Files modified:
- crates/poly-bot/src/lib.rs (added data_source module export)
- crates/poly-bot/Cargo.toml (added async-trait, futures-util, tokio-tungstenite)
- Cargo.toml (added workspace dependencies)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (62 tests, 19 new)

DataSource trait:
- async fn next_event() -> Result<Option<MarketEvent>, DataSourceError>
- has_more() -> bool for stream status
- current_time() -> Option<DateTime<Utc>> for replay mode
- shutdown() for graceful termination

MarketEvent enum:
- SpotPrice: Binance trade updates (asset, price, quantity, timestamp)
- BookSnapshot: Full orderbook from CLOB (bids, asks as PriceLevels)
- BookDelta: Incremental orderbook update (side, price, size)
- Fill: Order fill notification (outcome, size, price, fee)
- WindowOpen: New market window discovered
- WindowClose: Market window expired
- Heartbeat: Connection liveness check

LiveDataSource features:
- Connects to Binance WebSocket for spot prices
- Connects to Polymarket CLOB WebSocket for orderbooks
- Automatic reconnection with exponential backoff
- Dynamic subscription to new markets every 30s
- Ping/pong keepalive handling
- Shutdown via broadcast channel
- ActiveMarketsState (Arc<RwLock<HashMap>>) for market tracking

ReplayDataSource features:
- Loads historical data from ClickHouse (spot_prices, orderbook_snapshots, orderbook_deltas, market_windows)
- BinaryHeap priority queue for chronological event ordering
- Speed control (0.0 = max speed, 1.0 = real-time, >1.0 = faster)
- Configurable date range, event_ids, and assets filters
- Batch loading with configurable batch_size

Key decisions:
- Using async-trait crate for async trait methods
- LiveDataSource spawns background tasks for WebSocket connections
- Events merged through mpsc channel from multiple sources
- ReplayDataSource loads all data upfront into memory (suitable for backtest periods)
- Same DataSource trait works for both live trading and backtesting

Notes for next tasks:
- p3-5 (Executor) still unblocked
- Strategy code can use DataSource trait polymorphically
- ReplayDataSource ready for backtest mode (p8-4)
- LiveDataSource ready for live/paper/shadow modes

---

### [2026-01-12] Task p3-5: Executor trait
Files created:
- crates/poly-bot/src/executor.rs (trait and types)
- crates/poly-bot/src/executor/paper.rs (PaperExecutor)
- crates/poly-bot/src/executor/backtest.rs (BacktestExecutor)
- crates/poly-bot/src/executor/live.rs (LiveExecutor stub)

Files modified:
- crates/poly-bot/src/lib.rs (added executor module exports)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (97 tests, 34 new)

Executor trait features:
- place_order(&mut self, OrderRequest) -> Result<OrderResult, ExecutorError>
- cancel_order(&mut self, order_id) -> Result<OrderCancellation, ExecutorError>
- order_status(&self, order_id) -> Option<OrderResult>
- pending_orders(&self) -> Vec<PendingOrder>
- available_balance(&self) -> Decimal
- shutdown(&mut self)

OrderRequest types:
- OrderRequest with limit(), market(), ioc() constructors
- OrderType enum (Limit, Market, Ioc, Gtc)
- max_cost() calculation for balance checks

OrderResult enum:
- Filled(OrderFill) - fully filled
- PartialFill(PartialOrderFill) - partially filled
- Rejected(OrderRejection) - order rejected
- Pending(PendingOrder) - waiting for execution
- Cancelled(OrderCancellation) - order cancelled
- Helper methods: is_filled(), is_rejected(), filled_size(), filled_cost()

PaperExecutor features:
- Simulated fills without real money
- Configurable initial balance, fill latency, fee rate
- Balance enforcement and position limits
- Market order slippage simulation
- Position tracking (yes_shares, no_shares, cost_basis)
- Order history and status queries

BacktestExecutor features:
- Fills simulated by walking historical order book depth
- Partial fills when liquidity is insufficient
- Limit price enforcement (only fill at or better than limit)
- Configurable minimum fill ratio for partial fills
- Position and balance tracking
- BacktestStats for performance analysis

LiveExecutor (stub):
- Placeholder for real order submission
- Returns errors for all operations
- Will be fully implemented in Phase 5 (p5-3)

Key decisions:
- Executor trait uses async_trait for async methods
- All prices/quantities use rust_decimal::Decimal
- PaperExecutor doesn't consume order book (simplistic simulation)
- BacktestExecutor walks order book but doesn't modify it
- Partial fills tracked separately from full fills
- Order history stored for status queries

Notes for next tasks:
- Phase 3 now COMPLETE! All data_source and executor abstractions ready
- p4-1 (arb detection), p4-2 (toxic flow), p5-1 (shadow) now unblocked
- p6-1 (risk checks), p6-2 (circuit breaker), p7-1 (decision types) also unblocked
- Strategy code can use Executor trait polymorphically
- Same code works for live, paper, and backtest modes

---

### [2026-01-12] Task p4-1: Arbitrage detection
Files created:
- crates/poly-bot/src/strategy/mod.rs
- crates/poly-bot/src/strategy/arb.rs

Files modified:
- crates/poly-bot/src/lib.rs (added strategy module export)
- crates/poly-bot/src/state.rs (added Serialize/Deserialize to WindowPhase)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (117 tests, 20 new)

ArbThresholds features:
- Time-based margin thresholds: early (2.5%), mid (1.5%), late (0.5%)
- Configurable phase boundaries (early_threshold_secs, mid_threshold_secs)
- Minimum time remaining to trade (min_time_remaining_secs)
- for_phase() and phase_for_time() helpers

ArbOpportunity struct:
- Complete opportunity snapshot for decision making
- Event ID, asset, token IDs
- yes_ask, no_ask, combined_cost, margin, margin_bps
- max_size (limited by smaller side liquidity)
- seconds_remaining, phase, required_threshold
- confidence score (0-100)
- spot_price, strike_price for directional signals
- detected_at_ms timestamp
- expected_profit(), spot_suggests_yes(), has_significant_edge() helpers

ArbDetector features:
- detect(market) -> Result<ArbOpportunity, ArbRejection>
- Validates time remaining, quotes, liquidity
- Calculates margin and checks against phase-specific threshold
- Confidence scoring based on 5 factors:
  1. Margin above threshold (0-25 points)
  2. Time phase (0-15 points) - late = higher confidence
  3. Liquidity depth (0-20 points)
  4. Spread tightness (0-15 points)
  5. Spot price alignment (-5 to +10 points)
- has_potential_arb() for fast filtering
- Configurable min_confidence threshold

ArbRejection enum:
- NoQuotes: missing BBO
- NoArbitrage: combined >= 1.0
- BelowThreshold: margin below phase threshold
- InsufficientTime: < min_time_remaining
- NoLiquidity: size <= 0
- LowConfidence: confidence < min_confidence

Key decisions:
- All prices use rust_decimal::Decimal (NEVER f64)
- Confidence scoring provides signal quality indicator
- Fast path: has_potential_arb() for quick filtering before full detection
- ArbOpportunity is fully serializable for observability
- WindowPhase now has Serialize/Deserialize for storage

Notes for next tasks:
- p4-2 (toxic flow), p4-3 (position sizing) now unblocked
- Arb detector ready for strategy loop integration (p4-4)
- Confidence scoring can be tuned based on backtest results

---

### [2026-01-12] Task p4-2: Toxic flow detection
Files created:
- crates/poly-bot/src/strategy/toxic.rs

Files modified:
- crates/poly-bot/src/strategy/mod.rs (added toxic module export)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (136 tests, 19 new)

ToxicFlowDetector features:
- Rolling average order size tracking with configurable window (default 100)
- Detects large orders (>50x average) via size_multiplier_threshold
- Detects sudden appearance (<500ms since last update)
- Detects BBO shift (>100bps by default)
- Detects extreme size (>100x average = 2x threshold)
- Multi-indicator severity calculation:
  - Low: 1 indicator triggered
  - Medium: 2 indicators or >75x order
  - High: 3+ indicators or large+sudden
  - Critical: extreme size (>100x)
- Per-token state management with HashMap
- Fast pre-filtering via would_be_large() without state update

ToxicFlowConfig options:
- size_multiplier_threshold (default 50x)
- sudden_appearance_ms (default 500ms)
- rolling_window_size (default 100)
- min_samples (default 10) - minimum before detection active
- bbo_shift_threshold_bps (default 100 = 1%)

ToxicFlowWarning struct:
- Full diagnostic info (token_id, side, sizes, multiplier, timing)
- severity field for risk assessment
- indicators struct showing which checks triggered
- should_block() and size_multiplier() helpers for risk response

ToxicIndicators:
- large_order: size > threshold * average
- sudden_appearance: time < sudden_appearance_ms
- bbo_shift: BBO changed > bbo_shift_threshold_bps
- extreme_size: size > 2 * threshold * average

ToxicSeverity helpers:
- score() returns 0-100 numeric score
- should_block_trading() returns true for High/Critical
- size_multiplier() returns position size adjustment (0.75 to 0.0)

Key decisions:
- Rolling sum O(1) average calculation instead of O(n) iteration
- VecDeque for efficient front/back operations on window
- State per token to handle multiple markets independently
- All prices use rust_decimal::Decimal (NEVER f64)
- Severity ordering: Low < Medium < High < Critical
- First observation never flagged as sudden (time_since = u64::MAX)
- BBO shift calculated based on order side (buy affects ask, sell affects bid)

Notes for next task (p4-3):
- Position sizing now unblocked
- Need to integrate toxic severity with sizing decisions
- ToxicSeverity::size_multiplier() can reduce position size based on severity
- Consider blocking trades entirely at High/Critical severity

---

### [2026-01-12] Task p4-3: Position sizing
Files created:
- crates/poly-bot/src/strategy/sizing.rs

Files modified:
- crates/poly-bot/src/strategy/mod.rs (added sizing module export)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (156 tests, 19 new)

PositionSizer features:
- SizingConfig with configurable limits (base_order_size, max_position_per_market, max_total_exposure, min_order_size, max_liquidity_take)
- calculate_size() main calculation method with 7-step process:
  1. Start with base_order_size
  2. Limit by available liquidity
  3. Limit by max_liquidity_take (50% of book by default)
  4. Limit by max_position_per_market (minus existing position)
  5. Limit by max_total_exposure (minus current total exposure)
  6. Apply inventory imbalance multiplier (via InventoryState::size_multiplier())
  7. Apply toxic flow severity multiplier (via ToxicSeverity::size_multiplier())
- can_trade() fast check for hard limits
- max_possible_size() for limit-only calculation
- from_trading_config() constructor from TradingConfig

SizingResult features:
- size: calculated position size in shares
- is_valid: whether trade should execute
- expected_cost: size * combined_cost
- expected_profit: size * margin
- limit_reason: which limit was binding
- adjustments: multipliers applied (inventory, toxic, combined)

SizingLimit enum:
- BaseSize, PositionLimit, ExposureLimit, LiquidityLimit
- LiquidityTakeLimit, ImbalanceAdjustment, ToxicFlowAdjustment
- BelowMinimum, NoOpportunity

Key decisions:
- All prices/sizes use rust_decimal::Decimal (NEVER f64)
- max_liquidity_take prevents taking >50% of book (avoids slippage)
- Multipliers compound: combined = inventory_mult * toxic_mult
- Critical toxic severity (0x multiplier) effectively blocks trade
- SizingResult::invalid() constructor for rejected trades
- Detailed tracking of which limit was binding

Notes for next task (p4-4):
- Strategy loop now unblocked (all dependencies: p3-4, p4-1, p4-2, p4-3 complete)
- Need to wire together: DataSource -> arb detection -> toxic check -> sizing -> Executor
- Use GlobalState.can_trade() for single atomic check on hot path
- Fire-and-forget to observability channel via try_send()

---

### [2026-01-12] Task p4-4: Strategy loop
Files modified:
- crates/poly-bot/src/strategy/mod.rs (major expansion with StrategyLoop)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (165 tests, 9 new)

StrategyLoop features:
- Generic over DataSource and Executor traits for polymorphic use
- Main run() loop: receives events, processes, checks opportunities
- Event processing for all MarketEvent variants:
  - SpotPrice: updates local cache and GlobalState
  - BookSnapshot: applies to tracked market, records toxic flow
  - BookDelta: applies delta, records toxic flow
  - Fill: updates inventory, records success
  - WindowOpen: creates TrackedMarket, sets up token mapping
  - WindowClose: removes market from tracking
  - Heartbeat: updates time remaining, removes expired markets
- check_opportunities() hot path:
  - Single atomic can_trade() check first
  - Fast filter via has_potential_arb()
  - Full arb detection
  - Toxic flow warning from cached state
  - Blocks trade if toxic severity is High/Critical
  - Position sizing with inventory and exposure limits
  - Executes trade via executor (YES and NO orders)
- Fire-and-forget observability via try_send() (non-blocking)
- with_observability() builder method for decision capture
- Circuit breaker integration: trips after max_consecutive_failures
- Metrics tracking: events, opportunities, skipped, volume

StrategyConfig features:
- arb_thresholds, toxic_config, sizing_config
- max_consecutive_failures (default 3)
- block_on_toxic_high (default true)
- from_trading_config() constructor

TrackedMarket internal state:
- Per-market tracking: event_id, asset, token IDs, strike, window_end
- MarketState with YES/NO OrderBooks
- Inventory per market
- yes_toxic_warning, no_toxic_warning for cached toxic flow

TradeDecision struct:
- Full decision record for observability
- decision_id, event_id, asset
- opportunity, sizing, toxic_warning
- action (Execute, SkipSizing, SkipToxic, etc.)
- timestamp, latency_us

TradeAction enum:
- Execute: orders placed
- SkipSizing: size constraints prevented trade
- SkipToxic: toxic flow blocked trade
- SkipDisabled: trading disabled
- SkipCircuitBreaker: circuit breaker tripped

Key decisions:
- Toxic flow warnings cached per market during book updates
- Uses check_order() for toxic detection (not separate check method)
- Hot path stays fast: can_trade() is single atomic load
- Borrow checker satisfied by cloning event_id before mutable borrows
- execute_arb() places both YES and NO orders sequentially
- Order failures increment consecutive failure counter
- Observability uses bounded channel with try_send() to avoid blocking

Tests added:
- test_strategy_loop_creation
- test_window_open_tracking
- test_spot_price_update
- test_arb_detection_and_execution
- test_trading_disabled_skips_opportunities
- test_circuit_breaker_trips_on_failures
- test_trade_action_variants
- test_strategy_config_default
- test_trade_decision_serialization

Notes for next tasks:
- Phase 4 now COMPLETE! Full trading strategy implemented
- p5-1 (shadow bid manager) is next for execution enhancements
- p5-2 (price chasing) for aggressive fill pursuit
- p5-3 (live executor) for real order submission
- p6-1 (pre-trade risk checks) for additional safety
- p6-2 (circuit breakers) can extend current basic implementation

---

### [2026-01-12] Task p5-1: Shadow bid manager
Files created:
- crates/poly-bot/src/executor/shadow.rs

Files modified:
- crates/poly-bot/src/executor.rs (added shadow module)
- crates/poly-bot/src/lib.rs (added shadow type exports)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (184 tests, 19 new)

Shadow bid manager features:
- ShadowOrder struct with full order details (event_id, token_id, outcome, price, size)
- PrehashedOrder for EIP-712 pre-computation:
  - Stores domain_separator (constant per contract/chain)
  - Stores type_hash (constant per order struct)
  - Stores partial_encoding of known fields
  - finalize_struct_hash() completes encoding with price/size
  - compute_signing_hash() produces final hash for signing
- ShadowManager with DashMap storage keyed by (event_id, Outcome)
- create_shadow(): Creates and stores shadow with price offset
- fire(): Fires shadow synchronously, <2ms latency target
- fire_with_submitter(): Async version with custom order submission
- mark_filled()/mark_failed(): Status updates after submission
- cancel(): Cancel pending shadows
- cleanup_expired(): Remove old/terminal shadows
- pending_shadows()/active_count(): Query shadow state

ShadowStatus lifecycle:
- Pending -> Firing -> Submitted -> Filled/Failed
- Pending -> Expired (if timeout exceeded)
- Pending -> Cancelled (if explicitly cancelled)

ShadowFireResult struct:
- shadow_id, order_id, success flag
- latency_us for performance tracking
- error message on failure
- timestamp

Key decisions:
- DashMap for lock-free concurrent access
- Pre-hashing stores as much as possible at creation time
- Fire latency measured via Instant for accurate microsecond tracking
- Price offset applied in basis points (default 50 bps = 0.5%)
- Maker/taker amounts converted to u128 (USDC micro-units)
- Terminal states: Filled, Failed, Expired, Cancelled

Tests added (19 new):
- test_shadow_manager_creation
- test_create_shadow
- test_create_shadow_duplicate
- test_create_shadow_different_outcomes
- test_get_shadow
- test_fire_shadow
- test_fire_not_found
- test_fire_expired
- test_cancel_shadow
- test_mark_filled
- test_remove_shadow
- test_pending_shadows
- test_cleanup_expired
- test_active_count
- test_shadow_order_age
- test_prehashed_order
- test_shadow_disabled
- test_fire_with_submitter
- test_fire_with_submitter_failure

Notes for next tasks:
- p5-2 (price chasing) now unblocked
- p5-3 (live executor) depends on p5-1 (done) and p5-2
- Shadow manager ready for integration with LiveExecutor
- EIP-712 hashing uses placeholders - production needs real keccak256

---

### [2026-01-12] Task p5-2: Price chasing
Files created:
- crates/poly-bot/src/executor/chase.rs

Files modified:
- crates/poly-bot/src/executor.rs (added chase module)
- crates/poly-bot/src/lib.rs (added chase type exports)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (201 tests, 17 new)

PriceChaser features:
- ChaseConfig with configurable parameters:
  - enabled: toggle chasing on/off
  - step_size: price increment per iteration (default 0.001)
  - check_interval_ms: time between fill checks (default 100ms)
  - max_chase_time_ms: maximum chase duration (default 5000ms)
  - min_chase_size: minimum size to continue chasing
  - min_margin: minimum margin to maintain
- calculate_ceiling(): computes max price for buy orders
  - Formula: ceiling = 1.0 - other_leg_price - min_margin
  - For sells: floor = other_leg_price + min_margin
- chase_order() async method:
  - Places initial limit order at starting price
  - Loops: wait check_interval, check fill status, bump price
  - Stops when: filled, ceiling reached, timeout, rejected, or size too small
  - Cancels old order before placing new one at bumped price
  - Accumulates partial fills across iterations

ChaseResult features:
- success: whether fully filled
- filled_size, avg_price, total_cost, total_fee
- iterations: number of chase attempts
- final_price: last price reached
- stop_reason: enum explaining why stopped
- fills: vector of individual ChaseFill records
- arb_profit(): calculates profit given other leg price
- is_complete(): checks if fully filled without errors

ChaseStopReason enum:
- Disabled, Timeout, CeilingReached, OrderRejected
- SizeTooSmall, ExecutorError, MarketClosed, Cancelled

ChaseFill struct:
- Individual fill record during chase
- size, price, fee, iteration number

Key decisions:
- All prices use rust_decimal::Decimal (NEVER f64)
- Chase loop uses cancel-then-resubmit pattern
- Partial fills recorded immediately on detection
- Ceiling enforces minimum margin on arb trades
- Configurable via from_execution_config() from BotConfig
- Fully serializable with serde for observability

Tests added (17 new):
- test_chase_config_default
- test_calculate_ceiling_buy
- test_calculate_ceiling_sell
- test_chase_result_empty
- test_chase_result_immediate_fill
- test_chase_result_arb_profit
- test_chase_fill_accumulation
- test_build_result_success
- test_build_result_partial
- test_stop_reason_variants
- test_chase_order_immediate_fill
- test_chase_disabled
- test_chase_order_insufficient_funds
- test_from_execution_config
- test_chase_result_serialization
- test_chase_fill_serialization
- test_price_chaser_with_defaults

Notes for next tasks:
- p5-3 (live executor) now unblocked (depends: p5-1 done, p5-2 done)
- p6-1 (pre-trade risk checks) ready (depends: p3-3 done)
- p6-2 (circuit breakers) ready (depends: p3-2 done)
- PriceChaser ready for integration with LiveExecutor
- chase_order() can be used with any Executor implementation

---

### [2026-01-12] Task p5-3: Live executor
Files created/modified:
- crates/poly-bot/src/executor/live.rs (full implementation)

Files modified:
- Cargo.toml (added reqwest, ethers-core, sha3, hex dependencies)
- crates/poly-bot/Cargo.toml (added new dependencies)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (204 tests, 8 new)

LiveExecutor features:
- EIP-712 order signing for Polymarket CLOB API authentication
- Wallet struct: derives address from private key, signs message hashes
- Order submission via REST API with authenticated headers
- Order cancellation via REST API
- Fill tracking via polling (poll_order_status)
- Shadow bid firing on primary fills (fire_shadow_on_fill)
- Local balance tracking with update_balance_on_fill
- TrackedOrder state machine: Pending, PartiallyFilled, Filled, Cancelled

LiveExecutorConfig:
- api_endpoint: CLOB REST endpoint (production default)
- order_timeout_ms: maximum order timeout
- enable_shadow: enable shadow bid system
- chase_step_size: price increment for chasing
- fill_poll_interval_ms: polling interval
- max_poll_attempts: timeout for polling
- fee_rate_bps: 0 (Polymarket has 0% maker fees)

Wallet implementation:
- from_private_key(): creates from hex string
- derive_address(): keccak256(public_key) for Ethereum address
- sign_hash(): ECDSA signing with recovery ID for EIP-712

Order signing (EIP-712):
- compute_domain_separator(): Polymarket CTF Exchange domain
- compute_order_type_hash(): Order struct type hash
- compute_struct_hash(): ABI-encodes order parameters
- create_signed_order(): builds signed order for API

API types (api module):
- CreateOrderRequest, SignedOrder: order submission
- CreateOrderResponse: order ID extraction
- OrderStatusResponse: fill tracking
- CancelOrderRequest, CancelOrderResponse: cancellation
- ApiError: error handling

Executor trait implementation:
- place_order(): creates signed order, submits to API, tracks locally
- cancel_order(): cancels via API, updates tracked state
- order_status(): polls API or returns cached terminal state
- pending_orders(): returns all non-terminal orders
- available_balance(): returns tracked USDC balance
- shutdown(): cancels all pending orders, cleans up shadows

Tests added (8 new):
- test_live_executor_config_default
- test_domain_separator_computation
- test_order_type_hash_computation
- test_signature_to_bytes
- test_wallet_address_derivation
- test_wallet_invalid_key
- test_wallet_short_key
- test_live_executor_requires_credentials

Key decisions:
- Uses ethers-core k256 for ECDSA signing (no full ethers dependency)
- EIP-712 domain separator computed once at startup
- Order struct hash computed per-order (required for unique signatures)
- Private keys never logged (Debug trait redacts)
- Balance tracked locally (not queried from API)
- Shadow fires after fill detection (~2ms latency target)
- IOC orders poll immediately after submission
- All prices use rust_decimal::Decimal

Notes for next tasks:
- p5-4 (fill handling) now unblocked (depends: p5-3 done)
- p6-1 (pre-trade risk checks) ready (depends: p3-3 done)
- p6-2 (circuit breakers) ready (depends: p3-2 done)
- LiveExecutor ready for integration with strategy loop
- PriceChaser can wrap LiveExecutor for aggressive fills

---

### [2026-01-12] Task p5-4: Fill handling
Files created:
- crates/poly-bot/src/executor/fill.rs

Files modified:
- crates/poly-bot/src/executor.rs (added fill module)
- crates/poly-bot/src/lib.rs (added fill type exports)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (221 tests, 17 new)

FillHandler features:
- FillHandlerConfig with configurable parameters:
  - enable_shadow: toggle shadow firing on fills
  - shadow_latency_target_us: target latency for shadow fires (default 2000us)
  - log_slow_shadows: log when shadow exceeds target
  - min_fill_size: filter dust fills (default 0.01)
- process_fill(): main entry point for fill processing
  - Validates fill size against minimum
  - Updates partial fill tracking
  - Updates inventory in GlobalState
  - Fires shadow bid for opposite outcome
  - Sends result to observability channel
  - Updates metrics (volume, P&L)
- process_order_fill(): convenience for OrderFill type
- process_partial_fill(): convenience for PartialOrderFill type

FillData struct:
- Complete fill information for processing
- order_id, request_id, event_id, token_id, outcome
- size, price, fee, is_partial, cumulative_size, requested_size
- Helper methods: total_cost(), net_proceeds(), fill_ratio(), is_complete()
- from_full_fill() and from_partial_fill() constructors

PartialFillState tracking:
- Tracks cumulative filled size per order
- Weighted average price calculation across partials
- Total fees accumulated
- Shadow fired flag (fires only on first partial)
- First/last fill timestamps
- update() method for incremental updates
- mark_shadow_fired() to prevent duplicate shadow fires

FillResult struct:
- Comprehensive fill processing result
- fill: the processed FillData
- shadow_fired: whether shadow was triggered
- shadow_latency_us: shadow fire timing (if fired)
- shadow_order_id: shadow order ID (if fired)
- inventory_after: InventorySnapshot after fill
- processed_at: processing timestamp

InventorySnapshot struct:
- Point-in-time inventory state for fill result
- event_id, yes_shares, no_shares
- yes_cost_basis, no_cost_basis
- total_exposure, matched_pairs
- from_position() constructor from InventoryPosition

Key decisions:
- Shadow fires only on first partial fill (prevents duplicate shadows)
- Inventory updates use GlobalState shared state
- Observability uses try_send() for fire-and-forget (non-blocking)
- Partial fills tracked separately with incremental size calculation
- Cleanup method for stale partial fill state
- All prices use rust_decimal::Decimal (NEVER f64)

Tests added (17 new):
- test_fill_data_total_cost
- test_fill_data_fill_ratio
- test_fill_data_is_complete
- test_fill_data_from_order_fill
- test_fill_data_from_partial_fill
- test_partial_fill_state_update
- test_partial_fill_state_shadow_fired
- test_fill_handler_config_default
- test_fill_handler_creation
- test_fill_handler_track_partial
- test_fill_handler_full_fill_always_fires_shadow
- test_fill_handler_cleanup_stale
- test_fill_handler_process_fill
- test_fill_handler_inventory_update
- test_fill_handler_with_observability
- test_inventory_snapshot_from_position
- test_fill_result_serialization

Notes for next tasks:
- p6-3 (leg risk handling) now unblocked (depends: p5-4 done, p6-1)
- p6-1 (pre-trade risk checks) ready (depends: p3-3 done)
- p6-2 (circuit breakers) ready (depends: p3-2 done)
- FillHandler can integrate with LiveExecutor for real order fills
- Shadow bid integration uses SharedShadowManager from shadow.rs

---

### [2026-01-12] Task p6-1: Pre-trade risk checks
Files created:
- crates/poly-bot/src/risk/mod.rs
- crates/poly-bot/src/risk/checks.rs

Files modified:
- crates/poly-bot/src/lib.rs (added risk module export)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (248 tests, 27 new)

Risk checks implemented:
1. **Order validity**: Invalid size (<=0) or price (<=0 or >1.0) rejected
2. **Time remaining**: min_time_remaining_secs (default 30s) enforced
3. **Position limit**: max_position_per_market (cost basis) enforced
4. **Exposure limit**: max_total_exposure across all markets enforced
5. **Imbalance**: max_imbalance_ratio enforced, Crisis state always blocked
6. **Daily loss**: max_daily_loss limit (negative P&L threshold)
7. **Toxic flow**: toxic_flow_threshold (score >= threshold blocks)

RiskChecker features:
- RiskCheckConfig with all configurable limits
- PreTradeCheck builder pattern for constructing check context
- check() runs all 7 checks, returns RiskCheckResult
- can_trade() fast path for quick filtering (~ns)
- max_order_size() calculates largest order passing limits
- Size adjustment based on inventory state (Skewed=0.75, Exposed=0.50, Crisis=0.25)

PreTradeRejection types:
- InsufficientTime, PositionLimitExceeded, ExposureLimitExceeded
- ImbalanceTooHigh, DailyLossLimitReached, ToxicFlowBlocked
- InventoryCrisis, InvalidOrderSize, InvalidOrderPrice
- is_recoverable() distinguishes transient vs permanent rejections

Key decisions:
- All prices use rust_decimal::Decimal (NEVER f64)
- Fast path can_trade() checks only most common rejections
- Full check() runs all validations with detailed rejection reasons
- RiskCheckResult tracks passed_checks for debugging
- Serializable rejections for observability/logging

Notes for next tasks:
- p6-2 (circuit breakers) now ready (depends: p3-2 done)
- p6-3 (leg risk handling) depends on p6-1 (done) + p5-4 (done), NOW READY
- Risk module ready for strategy loop integration
- can_trade() designed for hot path usage

---

### [2026-01-12] Task p6-2: Circuit breakers
Files created:
- crates/poly-bot/src/risk/circuit_breaker.rs

Files modified:
- crates/poly-bot/src/risk/mod.rs (added circuit_breaker module export)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (269 tests, 21 new)

CircuitBreaker features:
- Lock-free atomic state management (tripped, half_open, consecutive_failures)
- can_trade() single atomic load (~10ns hot path)
- trip() sets tripped flag and records trip timestamp
- reset() manually resets to closed state
- record_success() resets failure counter, closes from half-open
- record_failure() increments counter, trips after max_consecutive_failures
- cooldown_elapsed() checks if cooldown period has passed
- try_auto_reset() transitions to half-open state after cooldown
- Half-open state allows probe trades to test recovery

CircuitBreakerConfig:
- max_consecutive_failures (default 3)
- cooldown Duration (default 5 minutes)
- auto_reset_enabled flag
- from_risk_config() constructor from RiskConfig

CircuitBreakerState enum:
- Closed: Normal operation, trading allowed
- Open: Tripped, trading blocked
- HalfOpen: Testing recovery, limited trading

CircuitBreakerStats:
- state, total_trips, total_successes, total_failures
- consecutive_failures, cooldown_remaining
- last_trip_reason (TripReason struct)
- Serializable with serde for observability

Key decisions:
- Single atomic load for can_trade() ensures ~10ns performance
- Ordering::Acquire/Release for hot path atomics
- Relaxed ordering for stats counters (exact counts not critical)
- Half-open state allows gradual recovery testing
- swap() used in trip() to ensure single increment on multiple calls
- SharedCircuitBreaker type alias for Arc<CircuitBreaker>

Tests added (21 new):
- test_circuit_breaker_default
- test_circuit_breaker_config
- test_record_success
- test_trip_after_failures
- test_manual_trip
- test_manual_reset
- test_cooldown_elapsed
- test_cooldown_remaining
- test_auto_reset_to_half_open
- test_half_open_success_closes
- test_half_open_failure_trips
- test_auto_reset_disabled
- test_stats
- test_trip_count_increments
- test_multiple_trip_calls_single_increment
- test_concurrent_access
- test_can_trade_is_fast
- test_state_display
- test_from_risk_config
- test_stats_serialization
- test_closed_state_no_cooldown_remaining

Notes for next tasks:
- p9-1 (unit tests) now unblocked (depends: p4-1, p4-2, p6-2 done, p3-1)
- Circuit breaker ready for integration with strategy loop
- SharedCircuitBreaker can be used across tasks
- GlobalState already has basic circuit breaker support - this provides richer features

---

### [2026-01-12] Task p6-3: Leg risk handling
Files created:
- crates/poly-bot/src/risk/leg_risk.rs

Files modified:
- crates/poly-bot/src/risk/mod.rs (added leg_risk module export)
- crates/poly-bot/src/lib.rs (added leg_risk type exports)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (293 tests, 24 new)

Leg risk handling features:
- LegState tracks two-legged trade execution (YES and NO legs)
- LegStatus enum: Pending, Submitted, PartialFill, Filled, Failed, Cancelled
- LegRiskManager assesses leg risk and recommends actions
- calculate_exposure() computes unhedged position value
- potential_loss() calculates worst-case loss at current prices

LegRiskAction responses:
- Wait: Within acceptable parameters, continue monitoring
- AggressiveChase: Pursue second leg with price improvement
- EmergencyClose: Exposure exceeded threshold, close position at market
- Complete: Trade successful, no action needed

Emergency close triggers:
- Exposure exceeds emergency_close_threshold (default $200)
- Timeout waiting for second leg (default 5 seconds)
- Market window closing (seconds_remaining <= 0)
- Second leg completely failed

Chase system features:
- ChaseReason: Normal, TimePressure, ExposureLimit
- Calculate max price maintaining minimum profit margin
- Aggressive price improvement under time pressure
- create_chase_order() generates IOC buy order
- create_emergency_close_order() generates IOC sell order

Inventory leg risk detection:
- inventory_has_leg_risk() checks imbalance ratio > 0.5
- inventory_exposure() calculates cost of unmatched position
- should_emergency_close_inventory() checks against threshold

Tests added (24 new):
- test_leg_state_new
- test_leg_state_update
- test_leg_state_complete
- test_leg_state_exposure
- test_leg_state_no_leg_risk_when_neither_filled
- test_leg_state_unfilled_leg
- test_leg_status_terminal
- test_leg_risk_manager_assess_complete
- test_leg_risk_manager_assess_wait
- test_leg_risk_manager_assess_chase
- test_leg_risk_manager_assess_emergency_close_exposure
- test_leg_risk_manager_assess_emergency_close_failed
- test_leg_risk_manager_assess_window_closing
- test_chase_reason_time_pressure
- test_create_emergency_close_order
- test_create_chase_order
- test_inventory_leg_risk
- test_inventory_exposure
- test_should_emergency_close_inventory
- test_leg_risk_config_from_risk_config
- test_leg_state_potential_loss
- test_leg_state_total_filled_size
- test_leg_status_filled_size
- test_leg_risk_assessment_serialization

Key decisions:
- All prices use rust_decimal::Decimal (NEVER f64)
- LegState is fully serializable for observability
- Emergency close uses IOC sell orders at minimum acceptable price
- Aggressive chase uses IOC buy orders with price ceiling
- Max chase price = 1.0 - filled_leg_price - min_profit (maintains arb margin)
- Time pressure triggers at < 60 seconds remaining
- Exposure limit triggers at half the emergency threshold

Notes for next tasks:
- Phase 6 (risk) now COMPLETE! All risk management features implemented
- p8-1 (live mode) now depends only on p7-3 (observability)
- p8-2 (paper mode) now depends only on p7-3 (observability)
- p7-1 (decision snapshot types) is READY (depends: p3-3 done)
- LegRiskManager can integrate with strategy loop for complete trade management

---

### [2026-01-12] Task p7-1: Decision snapshot types
Files created:
- crates/poly-bot/src/observability/mod.rs
- crates/poly-bot/src/observability/types.rs

Files modified:
- crates/poly-bot/src/lib.rs (added observability module and exports)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (313 tests, 22 new)

DecisionSnapshot features (hot path, primitives only):
- 64 bytes total size (#[repr(C)] for predictable layout)
- Pre-hashed event_id, yes_token_id, no_token_id to u64 (FNV-1a)
- Prices/sizes scaled to u16/u32 (basis points and cents)
- Timing: timestamp_ms (i64), latency_us (u32), seconds_remaining (u16)
- Inventory: yes/no shares, exposure, imbalance as scaled integers
- Signals: confidence (u8), toxic_severity (u8), phase (u8), asset (u8)
- Action type as u8 enum (Execute, SkipSizing, SkipToxic, etc.)
- No heap allocations - all primitive types

SnapshotBuilder features:
- Converts String/Decimal types to pre-hashed primitives
- Inline methods for zero-overhead conversion
- hash_string() uses FNV-1a for fast hashing
- decimal_to_bps(), decimal_to_cents() helper functions

DecisionContext features (async enrichment):
- Full string identifiers (event_id, token IDs)
- Decimal prices and sizes
- Optional enrichment: spot_price, strike_price, orders, fills
- Serializable with serde for ClickHouse storage
- from_snapshot() for reconstruction with string lookup

Counterfactual features (post-analysis):
- Original decision info (action, size, outcome)
- Hypothetical trade analysis (size, cost, P&L)
- Actual P&L and missed profit calculation
- calculate_arb_pnl() for arb trade settlement
- assess() determines if decision was correct in hindsight
- is_significant_miss() for >$1 missed profit
- needs_review() flags bad decisions on significant trades

ActionType enum (8 variants):
- Execute, SkipSizing, SkipToxic, SkipDisabled
- SkipCircuitBreaker, SkipRisk, SkipTime, SkipConfidence

OutcomeType enum:
- Unknown, Yes, No
- From<Outcome> and From<Option<Outcome>> conversions

ObservabilityEvent enum:
- Decision(DecisionSnapshot) for hot path
- Counterfactual(Counterfactual) for post-settlement
- Anomaly for detected issues (anomaly_type, severity, event_id_hash)

Key decisions:
- DecisionSnapshot uses #[repr(C)] for predictable memory layout
- All prices in basis points (10000 = 1.0) for u16 storage
- All sizes/costs in cents (100 = $1.00) for u32/i32 storage
- Pre-hashing uses FNV-1a (fast, non-cryptographic)
- Negative margin supported via i16 margin_bps
- Reserved bytes for future extension without breaking layout
- SnapshotBuilder uses consuming self for chaining

Notes for next task (p7-2):
- Need bounded mpsc channel with try_send() wrapper
- Capture function must inline for <10ns overhead
- Config flag to enable/disable observability
- Channel should drop on backpressure rather than blocking

---

### [2026-01-12] Task p7-2: Fire-and-forget capture
Files created:
- crates/poly-bot/src/observability/capture.rs

Files modified:
- crates/poly-bot/src/observability/mod.rs (added capture module export)
- crates/poly-bot/src/lib.rs (added capture type exports)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (336 tests, 23 new)

ObservabilityCapture features:
- Bounded mpsc channel with configurable capacity (default 1024)
- try_capture() hot path method with inlined atomic check + try_send()
- try_capture_event() for any ObservabilityEvent type
- Atomic enabled flag with Acquire/Release ordering for fast check
- Automatic disable on channel close (detect closed receiver)
- CaptureStats tracking: captured, dropped, skipped counters
- CaptureStatsSnapshot for point-in-time stats with drop_rate()
- Clone support for sharing across tasks (shared stats via Arc)
- from_config() and from_observability_config() constructors
- maybe_log_drops() with threshold to avoid log spam

CaptureConfig features:
- enabled: toggle capture on/off
- channel_capacity: bounded channel size
- log_drops: whether to log when events dropped
- drop_log_threshold: minimum drops before logging (avoid spam)
- disabled() and test_config() convenience constructors

Performance characteristics:
- Disabled path: <5ns (atomic load + return)
- Enabled path: ~50-100ns (atomic load + try_send + stats update)
- Non-blocking: try_send() returns immediately
- Drops on full: events silently dropped when channel full

Key decisions:
- Using tokio::sync::mpsc for async-compatible channel
- Atomic bool with Acquire ordering for fast enabled check
- Relaxed ordering for stats counters (exact counts not critical)
- SharedCapture type alias (Arc<ObservabilityCapture>) for sharing
- Sender stored as Option to support disabled mode without channel
- Stats shared via Arc for clone() to share counters

Tests added (23 new):
- test_capture_config_default
- test_capture_config_disabled
- test_capture_stats_snapshot
- test_capture_stats_drop_rate
- test_capture_stats_total_attempts
- test_create_capture_channel
- test_observability_capture_new
- test_observability_capture_disabled
- test_observability_capture_enable_disable
- test_try_capture_enabled
- test_try_capture_disabled
- test_try_capture_channel_full
- test_try_capture_event
- test_capture_clone
- test_from_config
- test_from_config_disabled
- test_create_shared_capture
- test_sender_method
- test_capture_overhead_disabled
- test_capture_overhead_enabled
- test_stats_reset
- test_async_receive
- test_channel_closed

Notes for next task (p7-3):
- Need async processor to receive from CaptureReceiver
- Enrich DecisionSnapshot to DecisionContext with string lookups
- Buffer and batch write to ClickHouse decisions table
- Handle backpressure by dropping oldest events

---

### [2026-01-12] Task p7-3: Async enrichment and storage
Files created:
- crates/poly-bot/src/observability/processor.rs

Files modified:
- crates/poly-bot/src/observability/mod.rs (added processor module export)
- crates/poly-bot/src/lib.rs (added processor type exports)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (352 tests, 16 new)

ObservabilityProcessor features:
- Receives events from CaptureReceiver via bounded mpsc channel
- Enriches DecisionSnapshot to DecisionRecord with string ID lookups
- InMemoryIdLookup for mapping hash -> string (event_id, yes_token, no_token)
- Configurable batch size and flush interval
- VecDeque buffer with backpressure handling (drops oldest when full)
- Batch writes to ClickHouse decisions table
- Processes Decision, Counterfactual, and Anomaly events
- Graceful shutdown with final flush
- Statistics tracking (received, processed, written, dropped, errors)

DecisionRecord struct (ClickHouse Row):
- Matches decisions table schema exactly
- All Decimal fields use rust_decimal::serde::str
- from_snapshot() constructor with enrichment

IdLookup trait:
- lookup_event_id(), lookup_yes_token(), lookup_no_token(), lookup_spot_price()
- InMemoryIdLookup implementation with async-friendly methods
- register_market() for bulk registration with FNV-1a hashing

ProcessorConfig:
- batch_size (default 1000)
- flush_interval (default 5s)
- max_buffer_size (default 10000)
- process_counterfactuals, process_anomalies flags
- from_observability_config() constructor

ProcessorStats with atomic counters:
- received, processed, written, dropped
- flushes, write_errors, enrichment_failures
- snapshot() for point-in-time stats
- drop_rate(), write_success_rate() helpers

Key decisions:
- FNV-1a hash function matches types.rs hash_string() exactly
- Fallback to "unknown_{hash:016x}" for missing ID lookups
- Counterfactuals stored as special DecisionRecord type
- Anomalies stored with type in decision_type field
- tokio::select! for concurrent recv, flush timer, shutdown
- spawn_processor() helper for background task creation

Tests added (16 new):
- test_hash_string
- test_decision_record_from_snapshot
- test_decision_record_skip_action
- test_in_memory_id_lookup
- test_in_memory_id_lookup_event_count
- test_processor_config_default
- test_processor_stats_snapshot
- test_processor_stats_drop_rate
- test_processor_stats_write_success_rate
- test_processor_stats_reset
- test_processor_creation
- test_processor_enrich_decision
- test_processor_enrich_decision_unknown_event
- test_processor_add_to_buffer_backpressure
- test_processor_process_counterfactual
- test_processor_process_anomaly

Notes for next tasks:
- p7-4 (counterfactual analysis) now unblocked
- p7-5 (anomaly detection) now unblocked
- p8-1 (live mode), p8-2 (paper mode), p8-3 (shadow mode) now unblocked
- Processor integrates with capture system for full observability pipeline
- InMemoryIdLookup should be populated from MarketDiscovery in live mode

---

### [2026-01-12] Task p7-4: Counterfactual analysis
Files created:
- crates/poly-bot/src/observability/counterfactual.rs

Files modified:
- crates/poly-bot/src/observability/mod.rs (added counterfactual module export)
- crates/poly-bot/src/lib.rs (added counterfactual type exports)
- crates/poly-common/src/schema.sql (added counterfactuals table)
- crates/poly-common/src/types.rs (added CounterfactualRecord)
- crates/poly-common/src/clickhouse.rs (added counterfactual inserter)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (376 tests, 22 new)
- cargo test -p poly-common: PASSED (8 tests)

CounterfactualAnalyzer features:
- PendingDecision: Tracks decisions awaiting settlement for counterfactual analysis
  - with_actual(), with_hypothetical(), with_context() builder methods
  - combined_cost(), hypothetical_pnl(), actual_pnl() calculations
  - is_expired() for cleanup
- Settlement: Represents market settlement (event_id, winning_outcome)
  - from_outcome_type() constructor from OutcomeType enum
- CounterfactualAnalyzer: Main analyzer for post-settlement what-if
  - record_decision(): Store decision for later analysis
  - analyze_settlement(): Generate counterfactuals when market settles
  - cleanup_expired(): Remove stale pending decisions
  - run_cleanup_loop(): Background task for periodic cleanup
- CounterfactualConfig:
  - max_pending_decisions (default 10,000)
  - decision_expiry_secs (default 1800 = 30 min)
  - significant_miss_threshold (default $1)
  - review_size_threshold (default $10)
  - toxic_skip_tolerance (default $5)
  - send_to_channel for observability integration
- CounterfactualStats: Atomic counters for monitoring
  - decisions_recorded, settlements_analyzed, counterfactuals_generated
  - correct_decisions, incorrect_decisions
  - total_missed_profit_cents, total_actual_profit_cents
  - flagged_for_review, expired_cleanups

Assessment logic:
- Execute + positive P&L = correct
- Execute + negative P&L = incorrect
- SkipSizing + positive hypothetical P&L = incorrect (missed profit)
- SkipToxic within tolerance ($5) = correct
- SkipToxic exceeds tolerance = incorrect
- SkipRisk + positive hypothetical P&L = incorrect
- SkipCircuitBreaker within $10 = correct

ClickHouse storage:
- Added counterfactuals table with full analysis fields
- CounterfactualRecord type for storage
- insert_counterfactuals() batch insert method
- counterfactual_inserter() for streaming inserts

Tests added (22 new):
- test_counterfactual_config_default
- test_pending_decision_new
- test_pending_decision_with_actual
- test_pending_decision_with_hypothetical
- test_pending_decision_hypothetical_pnl
- test_pending_decision_actual_pnl
- test_pending_decision_actual_pnl_zero_size
- test_pending_decision_is_expired
- test_pending_decision_not_expired
- test_settlement_new
- test_settlement_no_wins
- test_settlement_from_outcome_type
- test_counterfactual_stats_snapshot
- test_counterfactual_stats_reset
- test_analyzer_record_decision
- test_analyzer_multiple_decisions_per_event
- test_analyzer_analyze_settlement_execute_profit
- test_analyzer_analyze_settlement_skip_miss
- test_analyzer_toxic_skip_within_tolerance
- test_analyzer_toxic_skip_exceeds_tolerance
- test_analyzer_cleanup_expired
- test_analyzer_max_pending_decisions
- test_analyzer_stats_accumulation
- test_counterfactual_stats_total_profit

Key decisions:
- Pending decisions keyed by event_id with Vec for multiple decisions
- Uses Arc<RwLock<HashMap>> for thread-safe async access
- Configurable tolerance for toxic flow skips (avoids over-flagging)
- Counterfactuals sent to observability channel for unified storage
- Background cleanup loop for expired decisions
- All prices use rust_decimal::Decimal (NEVER f64)

Notes for next tasks:
- p7-5 (anomaly detection) still ready (depends: p7-3 done)
- p8-1 (live mode), p8-2 (paper mode), p8-3 (shadow mode), p8-4 (backtest) ready
- CounterfactualAnalyzer can integrate with strategy loop via record_decision()
- Settlement events from market window close trigger analyze_settlement()

---

### [2026-01-12] Task p7-5: Anomaly detection
Files created:
- crates/poly-bot/src/observability/anomaly.rs

Files modified:
- crates/poly-bot/src/observability/mod.rs (added anomaly module export)
- crates/poly-bot/src/lib.rs (added anomaly types export)
- crates/poly-common/src/schema.sql (added anomalies table)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (398 tests, 22 new)

AnomalyType enum (12 types):
- ExtremeMargin: Arb margin >10% (suspicious, may indicate stale data)
- FlashCrash: Sudden price drop >5% in flash window
- FlashSpike: Sudden price rise >5% in flash window
- LatencySpike: Execution latency exceeds threshold
- WideSpread: Bid-ask spread exceeds normal range
- TightSpread: Spread abnormally tight (may indicate wash trading)
- VolumeSpike: Sudden activity increase (>10x average)
- VolumeDrought: Unusually low activity (<10% of average)
- BookImbalance: One side of book has >80% of depth
- StaleData: No updates for extended period (>30s)
- CircuitBreakerTrip: Circuit breaker tripped event
- ConnectionIssue: Connection error detected

AnomalySeverity enum:
- Info (0): Logged, no action needed
- Low (1): Worth noting but not urgent
- Medium (2): Should be investigated
- High (3): Requires attention
- Critical (4): Immediate action needed
- score() method returns 0-100 for observability
- should_alert() returns true for High/Critical

AnomalyDetector features:
- check_extreme_margin(): Detects suspicious arb margins
- check_flash_price(): Async, tracks price changes per token
- check_latency_spike(): Detects execution delays
- check_spread(): Async, tracks rolling spread stats
- check_volume(): Async, compares to rolling average
- check_book_imbalance(): Detects one-sided order books
- check_stale_data(): Async, tracks last update time
- record_circuit_breaker_trip(): Records CB events
- record_connection_issue(): Records connection errors
- cleanup_stale_states(): Removes old token state

RollingStats for efficient windowed statistics:
- O(1) push, O(1) average calculation
- Configurable window size
- is_ready() when at least half full

AnomalyConfig:
- All thresholds configurable
- Enable/disable flags for detection and alerting
- alert_webhook_url for webhook alerts
- alert_cooldown_secs to prevent alert spam
- from_observability_config() constructor

Alert system:
- Logging at appropriate level (info/warn/error based on severity)
- Fire-and-forget to observability channel
- Optional webhook alerts for High/Critical
- Cooldown between alerts of same type

AnomalyStats:
- detected: Total anomalies detected
- by_type: Count per anomaly type (12 counters)
- alerts_sent, alert_failures: Alert tracking
- Atomic counters for thread safety

ClickHouse storage:
- Added anomalies table with full context fields
- anomaly_id, anomaly_type, severity, timestamp
- event_id, token_id (nullable)
- description, current_value, expected_value, deviation
- context field for additional JSON data

Tests added (22 new):
- test_anomaly_type_str
- test_anomaly_severity
- test_anomaly_severity_conversion
- test_anomaly_creation
- test_anomaly_to_observability_event
- test_anomaly_config_default
- test_anomaly_config_disabled
- test_rolling_stats
- test_detector_check_extreme_margin
- test_detector_check_flash_price
- test_detector_check_latency_spike
- test_detector_check_spread
- test_detector_check_volume
- test_detector_check_book_imbalance
- test_detector_cleanup_stale_states
- test_detector_record_circuit_breaker
- test_detector_record_connection_issue
- test_detector_disabled
- test_create_shared_detector
- test_anomaly_stats
- test_anomaly_stats_reset
- test_anomaly_serialization

Key decisions:
- Volume comparison uses average BEFORE adding new value (to detect spikes)
- Flash detection saves previous price before updating (for crash/spike direction)
- RollingStats uses fixed-size circular buffer with O(1) operations
- Webhook alerts use fire-and-forget tokio::spawn
- Alert cooldown prevents spam of same anomaly type
- All prices use rust_decimal::Decimal (NEVER f64)
- serde rename_all for consistent JSON serialization

Notes for next tasks:
- Phase 7 (Observability) now COMPLETE!
- p8-1 (live mode), p8-2 (paper mode), p8-3 (shadow mode), p8-4 (backtest) ready
- AnomalyDetector can integrate with strategy loop for real-time detection
- Webhook alerts ready for Slack/Discord integration

---

### [2026-01-12] Task p8-1: Live mode
Files created:
- crates/poly-bot/src/mode/mod.rs
- crates/poly-bot/src/mode/live.rs

Files modified:
- crates/poly-bot/src/lib.rs (added mode module and LiveMode exports)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot mode::live: PASSED (6 tests)

LiveMode features:
- LiveModeConfig with all component configs (data_source, executor, strategy, observability)
- LiveMode struct coordinates all components for live trading
- Validates TradingMode::Live and credentials on construction
- Wires LiveDataSource (Binance + Polymarket WebSockets) + LiveExecutor (real orders)
- Full observability pipeline:
  - ObservabilityCapture for fire-and-forget decision capture
  - ObservabilityProcessor for async enrichment and ClickHouse storage
  - CounterfactualAnalyzer for post-settlement what-if analysis
  - AnomalyDetector for real-time anomaly detection
- Decision forwarding: TradeDecision -> SnapshotBuilder -> DecisionSnapshot -> capture
- Graceful shutdown with:
  - Trading disabled via GlobalState
  - Broadcast shutdown signal
  - Strategy loop shutdown (cancels pending orders)
  - Wait for observability tasks with timeout
  - Final metrics logging
- request_shutdown() method for external shutdown triggers

LiveModeConfig options:
- data_source: LiveDataSourceConfig for WebSocket connections
- executor: LiveExecutorConfig for order submission
- strategy: StrategyConfig for arb detection/sizing
- observability: ObservabilityConfig for capture settings
- initial_balance: Starting USDC balance (default $1000)
- shutdown_timeout_secs: Max wait for cleanup (default 30s)
- from_bot_config() constructor from BotConfig

Tests added (6):
- test_live_mode_config_default
- test_live_mode_config_from_bot_config
- test_live_mode_requires_live_trading_mode
- test_live_mode_requires_credentials
- test_live_mode_shutdown_signal
- test_live_mode_state_access

Key decisions:
- Uses Arc<ObservabilityCapture> for shared capture across tasks
- Separate channel for TradeDecision -> spawned task converts to DecisionSnapshot
- ObservabilityProcessor runs as spawned background task
- CounterfactualAnalyzer runs cleanup loop as spawned background task
- AnomalyDetector available but not directly wired (used by strategy)
- Broadcast channel for shutdown coordination
- Strategy loop runs in main select! with shutdown receiver

Notes for next tasks:
- p8-2 (paper mode) similar structure with PaperExecutor
- p8-3 (shadow mode) similar with NoOpExecutor
- p8-4 (backtest mode) uses ReplayDataSource + BacktestExecutor
- p8-5 (main binary) wires all modes together with CLI
- Live mode ready for deployment with proper credentials

---

### [2026-01-12] Task p8-2: Paper mode
Files created:
- crates/poly-bot/src/mode/paper.rs

Files modified:
- crates/poly-bot/src/mode/mod.rs (added paper module export)
- crates/poly-bot/src/lib.rs (added PaperMode, PaperModeConfig exports)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (411 tests, 7 new)

PaperMode features:
- Wires LiveDataSource (real WebSocket data) + PaperExecutor (simulated fills)
- Real-time market data from Binance and Polymarket WebSockets
- Configurable fill latency simulation for realistic timing
- Virtual balance and position tracking
- Full observability pipeline:
  - ObservabilityCapture for fire-and-forget decision capture
  - ObservabilityProcessor for async enrichment and ClickHouse storage
  - CounterfactualAnalyzer for post-settlement what-if analysis
  - AnomalyDetector for real-time anomaly detection
- Decision forwarding: TradeDecision -> SnapshotBuilder -> DecisionSnapshot -> capture
- Graceful shutdown with task cleanup and final metrics logging
- request_shutdown() method for external shutdown triggers

PaperModeConfig options:
- data_source: LiveDataSourceConfig for WebSocket connections
- executor: PaperExecutorConfig for simulated fills
- strategy: StrategyConfig for arb detection/sizing
- observability: ObservabilityConfig for capture settings
- initial_balance: Starting virtual USDC balance (default $10,000)
- shutdown_timeout_secs: Max wait for cleanup (default 30s)
- from_bot_config() constructor from BotConfig

PaperExecutorConfig integration:
- Uses paper_fill_latency_ms from ExecutionConfig
- Enforces max_position_per_market from TradingConfig
- Fee rate set to 0 (Polymarket has 0% maker fees)
- Balance enforcement enabled

Tests added (7):
- test_paper_mode_config_default
- test_paper_mode_config_from_bot_config
- test_paper_mode_requires_paper_trading_mode
- test_paper_mode_accepts_paper_mode
- test_paper_mode_shutdown_signal
- test_paper_mode_state_access
- test_paper_mode_executor_config

Key decisions:
- Structure mirrors LiveMode for consistency
- Does not require wallet credentials (only uses simulated execution)
- Uses same observability pipeline as live mode for comparable metrics
- Default $10,000 virtual balance (higher than live for strategy testing)
- Logs "Paper trading" in messages to distinguish from live mode

Notes for next tasks:
- p8-3 (shadow mode) now ready - similar structure with NoOpExecutor
- p8-4 (backtest mode) now ready - uses ReplayDataSource + BacktestExecutor
- Paper mode validates strategy with real market conditions safely
- Can benchmark expected P&L against real opportunities

---

### [2026-01-12] Task p8-3: Shadow mode
Files created:
- crates/poly-bot/src/executor/noop.rs
- crates/poly-bot/src/mode/shadow.rs

Files modified:
- crates/poly-bot/src/executor.rs (added noop module)
- crates/poly-bot/src/mode/mod.rs (added shadow module export)
- crates/poly-bot/src/lib.rs (added NoOpExecutor, ShadowMode exports)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (429 tests, 18 new)

NoOpExecutor features:
- Implements Executor trait but never executes orders
- Logs all order requests for opportunity tracking
- Tracks orders_received count and volume_received
- Configurable virtual_balance for strategy compatibility
- Configurable rejection_reason for all orders
- Configurable log_orders flag for verbose/quiet modes

ShadowMode features:
- Wires LiveDataSource (real WebSocket data) + NoOpExecutor (logs only)
- Real-time market data from Binance and Polymarket WebSockets
- All detected opportunities logged but never executed
- Full observability pipeline:
  - ObservabilityCapture for fire-and-forget decision capture
  - ObservabilityProcessor for async enrichment and ClickHouse storage
  - CounterfactualAnalyzer for post-settlement what-if analysis
  - AnomalyDetector for real-time anomaly detection
- Decision forwarding: TradeDecision -> SnapshotBuilder -> DecisionSnapshot -> capture
- Graceful shutdown with task cleanup and final metrics logging
- request_shutdown() method for external shutdown triggers

ShadowModeConfig options:
- data_source: LiveDataSourceConfig for WebSocket connections
- executor: NoOpExecutorConfig for logging settings
- strategy: StrategyConfig for arb detection/sizing
- observability: ObservabilityConfig for capture settings
- virtual_balance: Virtual balance for sizing calculations (default $10,000)
- shutdown_timeout_secs: Max wait for cleanup (default 30s)
- from_bot_config() constructor from BotConfig

Tests added (18 new):
- test_noop_executor_config_default
- test_noop_executor_new
- test_noop_executor_place_order_rejected
- test_noop_executor_tracks_orders
- test_noop_executor_cancel_order
- test_noop_executor_order_status
- test_noop_executor_pending_orders
- test_noop_executor_available_balance
- test_noop_executor_shutdown
- test_noop_executor_custom_rejection_reason
- test_noop_executor_sell_order_tracking
- test_shadow_mode_config_default
- test_shadow_mode_config_from_bot_config
- test_shadow_mode_requires_shadow_trading_mode
- test_shadow_mode_accepts_shadow_mode
- test_shadow_mode_shutdown_signal
- test_shadow_mode_state_access
- test_shadow_mode_executor_config

Key decisions:
- Structure mirrors LiveMode and PaperMode for consistency
- NoOpExecutor returns Rejected for all orders (clearly indicates shadow mode)
- Does not require wallet credentials (no real execution)
- Uses same observability pipeline for comparable metrics
- Tracks would-be trades for strategy benchmarking
- Default $10,000 virtual balance for consistent sizing calculations

Notes for next tasks:
- p8-4 (backtest mode) now ready - uses ReplayDataSource + BacktestExecutor
- p8-5 (main binary) blocked on p8-4
- p9-1 (unit tests) is ready - can run in parallel with p8-4
- Shadow mode ready for feed validation and opportunity benchmarking

---

### [2026-01-12] Task p8-5: Main binary
Files created:
- crates/poly-bot/src/main.rs

Files modified:
- crates/poly-bot/src/lib.rs (added BacktestMode exports)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (446 tests, 7 new)
- cargo run -p poly-bot -- --help: PASSED

CLI features implemented:
- `poly-bot --mode <MODE>`: Select trading mode (live, paper, shadow, backtest)
- `poly-bot --config <FILE>`: Custom config file path (default: config/bot.toml)
- `poly-bot --clickhouse-url <URL>`: Override ClickHouse URL
- `poly-bot --assets <ASSETS>`: Comma-separated assets to trade
- `poly-bot --start <DATE>`: Backtest start date (YYYY-MM-DD)
- `poly-bot --end <DATE>`: Backtest end date (YYYY-MM-DD)
- `poly-bot --speed <SPEED>`: Backtest speed multiplier (0=max, 1.0=real-time)
- `poly-bot --sweep`: Enable parameter sweep mode

Main binary features:
- Config file loading with fallback to defaults
- Environment variable overrides (POLY_PRIVATE_KEY, POLY_API_KEY, etc.)
- CLI argument overrides (highest priority)
- ClickHouse connection test and table creation
- Mode-specific initialization:
  - Live: LiveMode with credentials validation
  - Paper: PaperMode with simulated execution
  - Shadow: ShadowMode for feed validation
  - Backtest: BacktestMode with date range and sweep support
- Graceful shutdown on Ctrl+C/SIGTERM
- Final metrics logging for backtest mode
- Sweep results summary with best parameter combination

Shutdown handling:
- Unix: SIGTERM and SIGINT via tokio::signal
- Windows: Ctrl+C via tokio::signal::ctrl_c()
- Spawns async shutdown handler that sets control.request_shutdown()
- Each mode has its own shutdown coordination with observability tasks

Tests added (7 new):
- test_cli_parsing
- test_cli_mode_override
- test_cli_backtest_options
- test_cli_assets_override
- test_cli_clickhouse_override
- test_cli_config_path
- test_cli_combined_options

Key decisions:
- Using clap derive for CLI argument parsing (consistent with poly-collect, poly-import)
- Config loading priority: CLI > env vars > config file > defaults
- Backtest-specific args (--start, --end, --speed, --sweep) only apply in backtest mode
- Each mode creates its own shutdown handler with state reference
- Detailed backtest summary including sweep results and best run

Notes for Phase 8 completion:
- Phase 8 (trading modes) is now COMPLETE!
- All four modes implemented: live, paper, shadow, backtest
- Main binary wires everything together with full CLI support
- Ready for Phase 9 (testing and validation)

---

---

### [2026-01-12] Task p9-1: Phase 9: Unit tests
Files reviewed:
- crates/poly-bot/src/strategy/arb.rs (23 tests)
- crates/poly-bot/src/types.rs (16 tests)
- crates/poly-bot/src/risk/circuit_breaker.rs (23 tests)
- crates/poly-bot/src/strategy/toxic.rs (21 tests)
- crates/poly-bot/src/config.rs (14 tests)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (439 unit tests)

Test coverage summary:
- Arb detection: threshold selection, phase detection, confidence scoring, rejection reasons
- Inventory state: state transitions (Balanced/Skewed/Exposed/Crisis), size multipliers
- Circuit breaker: trip after failures, auto-reset, half-open state, concurrent access
- Toxic flow: large order detection, sudden appearance, BBO shift, severity calculation
- Config: TOML parsing, env overrides, CLI overrides, validation

All core logic already had comprehensive test coverage from previous phases.

---

### [2026-01-12 14:30] Task: Phase 9: Integration tests
Files changed:
- crates/poly-bot/tests/integration_strategy.rs (new)
- crates/poly-bot/tests/integration_replay.rs (new)
- crates/poly-bot/tests/integration_observability.rs (new)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test: PASSED (66 new integration tests)

Tests created:
1. integration_strategy.rs (12 tests):
   - Strategy + mock executor flow
   - Arb detection with trading enabled/disabled
   - Multiple market handling
   - Spot price updates via GlobalState
   - Circuit breaker logic
   - Observability channel integration
   - Metrics tracking
   - Window close removes market

2. integration_replay.rs (19 tests):
   - ReplayConfig default values and custom config
   - Event priority queue ordering
   - MarketEvent display, timestamp, is_heartbeat
   - Book snapshot/delta/window event fields
   - Mock replay source implementation
   - DataSource trait implementation

3. integration_observability.rs (35 tests):
   - CaptureConfig default/disabled
   - CaptureStats tracking and snapshots
   - Drop rate calculation
   - Channel creation and receive
   - Enable/disable capture
   - Channel full handling (backpressure)
   - Clone shares stats
   - High throughput test
   - SnapshotBuilder API coverage
   - DecisionSnapshot accessors

Learnings:
- Integration tests placed in crates/poly-bot/tests/ not workspace root
- SnapshotBuilder uses event_id(&str) not event_id_hash(u64) - hashes internally
- ObservabilityEvent has Decision, Counterfactual, Anomaly variants (no Fill variant)
- StrategyLoop.executor field is private - test via metrics and GlobalState
- DecisionSnapshot uses _bps/_cents suffixes for packed integer fields

Notes for next task:
- p9-3 (Backtest validation) requires collected data and ClickHouse

---

### [2026-01-12] Task p9-3: Backtest validation
Files created:
- crates/poly-bot/tests/integration_backtest_validation.rs

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (468 tests total, 29 new)

Backtest validation tests (29 tests):

1. P&L Calculation Validation (5 tests):
   - test_pnl_calculation_basic: Verifies $500 profit = 5% return
   - test_pnl_calculation_loss: Verifies negative P&L displays correctly
   - test_pnl_calculation_zero_initial_balance: Division by zero edge case
   - test_pnl_calculation_large_numbers: $1 billion balance, no overflow
   - test_pnl_calculation_fractional_returns: Sub-1% returns calculated precisely

2. Impossible State Validation (4 tests):
   - test_prices_are_never_negative: Binary option prices 0.0-1.0
   - test_sizes_are_never_negative: Order sizes non-negative
   - test_order_book_state_consistency: Best bid < best ask (no crossed book)
   - test_executor_balance_never_negative_after_fees: Balance stays non-negative

3. BacktestResult Consistency (4 tests):
   - test_backtest_result_trades_sum: filled + partial + rejected <= placed
   - test_backtest_result_fees_bounded: 0 <= fees < volume
   - test_backtest_result_duration_positive: Duration > 0
   - test_backtest_result_time_range_valid: end_time > start_time

4. Sweep Parameter Validation (4 tests):
   - test_sweep_parameter_values_monotonic: Values in ascending order
   - test_sweep_parameter_includes_bounds: Start and end values included
   - test_sweep_parameter_single_value: start == end returns single value
   - test_sweep_parameter_small_steps: Fine-grained steps work correctly

5. P&L Report Format Validation (2 tests):
   - test_pnl_report_contains_required_fields: All sections present
   - test_pnl_report_formats_negative_pnl_correctly: Negative P&L displayed

6. Executor Edge Cases (5 tests):
   - test_executor_zero_size_order_rejected: Zero size rejected
   - test_executor_handles_empty_book: No liquidity rejected
   - test_executor_rejects_when_insufficient_funds: Balance enforcement
   - test_executor_position_tracking_accuracy: Buy/sell updates position
   - test_executor_stats_consistency: Stats sum correctly

7. Arithmetic Invariant Tests (5 tests):
   - test_binary_option_prices_sum_constraint: YES + NO = 1.0
   - test_arbitrage_margin_calculation: margin = 1.0 - (yes_ask + no_ask)
   - test_no_arbitrage_when_prices_exceed_one: margin < 0 means no arb
   - test_position_value_bounds: 100 YES+NO pairs = $100 at settlement
   - test_fee_calculation_precision: Exact decimal arithmetic

Key validations implemented:
- P&L = final_balance - initial_balance (exact)
- Return % = (P&L / initial_balance) * 100 (handles zero balance)
- All prices in valid range [0, 1] for binary options
- Order book never crossed (best_bid < best_ask)
- Balance never goes negative after fees
- Position tracking accurate through buy/sell cycles
- Fee calculations use exact decimal arithmetic (not floating point)
- Arbitrage margin calculation verified: margin = 1 - combined_cost

Learnings:
- best_bid()/best_ask() return Option<Decimal>, not PriceLevel
- MetricsSnapshot has no Default impl - must construct explicitly
- Binary option constraints: YES + NO mid prices should sum to 1.0
- Backtest executor rejects zero-size orders via ExecutorError
- Order book deltas with size=0 remove levels

Notes:
- ALL TASKS COMPLETE! Project fully implemented from Phase 1-9
- 35 tasks total, all marked completed
- Full arbitrage detection, execution, and risk management implemented

---

# V3 Three-Engine Strategy

## [2026-01-14] Strategy Upgrade Initiated

Source: spec/POLYMARKET_BOT_SPEC_v3_RUST.md

### New Strategy: Three Profit Engines
1. **Directional** (60-70%): Bet based on BTC price vs strike
2. **Arbitrage** (15-25%): Capture gaps when UP + DOWN < $0.98
3. **Maker Rebates** (10-20%): Earn from maker orders being filled

### Key Changes from V2
- Confidence-based order sizing (replaces fixed sizing)
- Signal system: StrongUp/LeanUp/Neutral/LeanDown/StrongDown
- Balance-scaled config (20% per market, 200 expected trades)
- P&L-based risk management (daily loss, consecutive losses)
- Dynamic fee rate from API (GET /fee-rate)
- Rewards tracking from API (GET /rewards/markets/current)

### Configurable Layers
- Engines: Each can be enabled/disabled with priority
- Sizing: limits | confidence | hybrid
- Risk: circuit_breaker | daily_pnl | both

### API Endpoints (from rs-clob-client)
- GET /fee-rate?token_id=X -> { base_fee: u32 }
- GET /rewards/markets/current -> CurrentRewardResponse[]
- GET /rewards/user/percentages -> HashMap<String, Decimal>
- GET /rewards/user/total?date=X -> TotalUserEarningResponse

## Pending Work

See tasklist.json for 23 tasks across 9 phases.

---

---

### [2026-01-14] Task p1-1: Add Signal enum and detection
Files created:
- crates/poly-bot/src/strategy/signal.rs

Files modified:
- crates/poly-bot/src/strategy/mod.rs (added signal module export)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot strategy::signal: PASSED (29 tests)

Signal module features:
- Signal enum: StrongUp, LeanUp, Neutral, LeanDown, StrongDown
- up_ratio() returns allocation ratio for UP (0.78, 0.60, 0.50, 0.40, 0.22)
- down_ratio() returns allocation ratio for DOWN (complement of up_ratio)
- is_directional(), is_strong(), bias_strength() helper methods
- SignalThresholds struct (strong, lean thresholds)
- get_thresholds(minutes_remaining) with 5 time brackets:
  - >10 min: strong=0.20%, lean=0.08% (early)
  - 5-10 min: strong=0.15%, lean=0.05% (mid-early)
  - 2-5 min: strong=0.10%, lean=0.03% (mid)
  - 1-2 min: strong=0.05%, lean=0.02% (late)
  - <1 min: strong=0.03%, lean=0.01% (very late)
- get_signal(spot, strike, minutes) returns Signal based on distance
- calculate_distance(spot, strike) returns distance as ratio
- distance_bps(spot, strike) returns distance in basis points

Key decisions:
- Thresholds tighten as time remaining decreases (more certainty = smaller moves matter)
- Allocation ratios: Strong=78/22, Lean=60/40, Neutral=50/50
- All calculations use rust_decimal::Decimal (never f64)
- Exported from strategy::mod.rs for public access

Notes for next task:
- p1-2 (Confidence types) depends on p1-1 (done)
- Signal system ready for DirectionalDetector in Phase 5

---

### [2026-01-14] Task p1-2: Add Confidence types for sizing
Files created:
- crates/poly-bot/src/strategy/confidence.rs

Files modified:
- crates/poly-bot/src/strategy/mod.rs (added confidence module and exports)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (44 confidence tests)

ConfidenceFactors struct:
- distance_to_strike: Decimal (absolute dollars from strike)
- minutes_remaining: Decimal
- signal: Signal (from signal.rs)
- book_imbalance: Decimal (-1.0 to +1.0)
- favorable_depth: Decimal (in dollars)

Confidence struct:
- time: Decimal multiplier (0.6-1.6 range)
- distance: Decimal multiplier (0.6-1.5 range)
- signal: Decimal multiplier (0.7-1.4 range)
- book: Decimal multiplier (0.9-1.44 range)
- total_multiplier() using geometric mean with 0.5x-3.0x caps

ConfidenceCalculator functions:
- calculate(factors) -> Confidence
- time_confidence(minutes, distance) - time  distance interaction
- distance_confidence(distance) - distance from strike
- signal_confidence(signal) - Signal strength
- book_confidence(imbalance, depth) - order book factors

Key decisions:
- Geometric mean: (time  distance  signal  book)^0.25  1.5
- Multiplier caps at MIN_MULTIPLIER (0.5x) and MAX_MULTIPLIER (3.0x)
- Time confidence scales down if close to strike (distance modifier)
- Book confidence combines imbalance and depth factors
- All math uses Decimal, f64 only for power operation

Tests verified:
- All spec examples (weak/strong confidence scenarios)
- All multiplier cap boundaries
- All component calculation ranges
- Serialization roundtrip

Notes for next task:
- p3-2 (ConfidenceSizer) depends on p1-2 (done)
- Confidence types ready for dynamic order sizing

---

### [2026-01-14 08:36] Task p1-3: Add Position and trade decision types
Files modified:
- crates/poly-bot/src/types.rs (added EngineType, TradeDecision, Position types)
- crates/poly-bot/src/lib.rs (exported new types)

Files updated:
- tasks/tasklist.json (marked p1-3 as completed)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo check: PASSED
- cargo test -p poly-bot types::: PASSED (60 tests including 34 new)

Types implemented:
- EngineType enum: Arbitrage, Directional, MakerRebates with priority ordering
- TradeDecision enum: Approve, Reject, ReduceSize, RebalanceRequired
- Position struct: up_shares, down_shares, up_cost, down_cost tracking

Position methods:
- total_cost(), total_shares() - basic accessors
- up_ratio(), down_ratio() - allocation ratios (default 0.5 if empty)
- min_side_ratio() - hedge ratio for risk checks
- calculate_pnl(up_wins) - settlement P&L calculation
- guaranteed_pnl() - matched pair profit
- unrealized_pnl(up_price, down_price) - mark-to-market
- to_inventory() / from_inventory() - compatibility conversions

TradeDecision methods:
- reject(reason) - factory for Reject variant
- allows_trading() - true for Approve or ReduceSize
- is_blocked() - true for Reject
- requires_rebalance() - true for RebalanceRequired

Key decisions:
- Position uses UP/DOWN naming (directional), Inventory uses YES/NO (outcome)
- All financial values use Decimal per project convention
- Position provides conversion to/from Inventory for integration
- TradeDecision matches spec exactly for PnlRiskManager integration

Notes for next tasks:
- Position ready for use in PnlRiskManager (p4-1)
- EngineType ready for DecisionAggregator (p7-2)
- TradeDecision ready for risk checking integration

---

### [2026-01-14] Task p2-1: Add fee rate client
Files created:
- crates/poly-bot/src/api/mod.rs
- crates/poly-bot/src/api/fees.rs

Files modified:
- crates/poly-bot/src/lib.rs (added api module and exports)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot api::: PASSED (14 tests)

FeeRateClient features:
- Fetches from GET /fee-rate?token_id=X endpoint
- In-memory RwLock<HashMap> caching per token
- FeeRateResponse with base_fee in basis points
- Supports both "base_fee" and "fee_rate_bps" JSON fields (serde alias)
- Helper methods: as_decimal(), has_fees()
- prefetch_fee_rates() for warming cache at session start
- clear_cache() for new market sessions

FeeRateError variants:
- Http: reqwest errors
- ApiError: non-2xx responses with status and body
- Json: parse failures
- InvalidTokenId: empty token validation

Key decisions:
- Using RwLock (not DashMap) since fee rates are read-heavy, write-rare
- 10s request timeout
- Default base URL: https://clob.polymarket.com
- Support custom URLs for testing
- Fee rate cached indefinitely per client lifetime (matches market session pattern)

Notes for next task:
- p2-2 (rewards client) depends on p2-1 (done)
- Similar pattern: HTTP fetch + caching + response types

---

### [2026-01-14] Task p2-2: Add rewards client
Files created:
- crates/poly-bot/src/api/rewards.rs

Files modified:
- crates/poly-bot/src/api/mod.rs (added rewards module export)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot api::rewards: PASSED (19 tests)

RewardsClient features:
- fetch_current_rewards() -> Vec<CurrentRewardResponse>
  - Fetches from GET /rewards/markets/current
  - Returns active reward programs with configs
- get_reward_config(condition_id) -> Option<RewardsConfig>
  - Returns cached config or fetches and caches all
  - In-memory cache per client instance
- fetch_reward_percentages() -> HashMap<String, Decimal>
  - Fetches from GET /rewards/user/percentages
  - Returns user's share of daily rewards per market
- fetch_user_earnings(date) -> TotalUserEarningResponse
  - Fetches from GET /rewards/user/total?date=X
  - Returns total and per-market earnings breakdown
  - Validates date format (YYYY-MM-DD)
- prefetch_configs() for cache warming
- clear_cache() for session boundaries
- cache_size() and is_cached() for introspection

Types implemented:
- CurrentRewardResponse: API response for market rewards config
  - condition_id, rewards_daily_rate, rewards_min_size, rewards_max_spread, active
  - is_active() checks both flag and non-zero rate
- RewardsConfig: Simplified config for strategy use
  - from_response() converter
  - qualifies(size, spread_bps) checks eligibility
- UserPercentagesResponse: Wrapper for percentage map
- UserEarning: Single market earning entry
- TotalUserEarningResponse: Date's total earnings with breakdown
- RewardsError: HTTP, ApiError, Json, InvalidDate variants

Key decisions:
- Following same patterns as FeeRateClient (caching, error handling)
- RewardsConfig is a simplified struct for strategy use vs full API response
- qualifies() method makes it easy to check if an order earns rewards
- Cache populated on first get_reward_config() call (lazy loading)
- Date validation is simple format check (len=10, two dashes)

Notes for next task (p2-3):
- MarketSession needs to combine fee rate and reward config
- Can use FeeRateClient and RewardsClient together
- Consider adding MarketSession to TrackedMarket or as standalone

---

### [2026-01-14] Task p2-3: Create MarketSession with cached API data
Files modified:
- crates/poly-bot/src/types.rs (added MarketSession, TokenPair, MarketSessionError)
- crates/poly-bot/src/lib.rs (exported new types)

Files updated:
- tasks/tasklist.json (marked p2-3 as completed)

Verification:
- cargo clippy -- -D warnings: PASSED
- cargo test -p poly-bot: PASSED (76 tests in types module)

Types implemented:
- TokenPair: YES/NO token ID container with iter(), contains(), outcome_for() helpers
- MarketSessionError: Error enum for FeeRate and Rewards API failures
- MarketSession: Cached API data for a trading session

MarketSession fields:
- event_id, condition_id: Market identifiers
- asset: CryptoAsset (BTC, ETH, SOL, XRP)
- tokens: TokenPair for YES/NO token IDs
- strike_price: Decimal strike for up/down market
- window_end: DateTime<Utc> for session expiry
- fee_rate_bps: u32 cached from FeeRateClient
- reward_config: Option<RewardsConfig> cached from RewardsClient
- created_at: DateTime<Utc> for session start

MarketSession methods:
- new(): Async constructor that fetches and caches API data
- with_data(): Sync constructor for testing/manual use
- fee_rate_decimal(): Convert bps to Decimal (0.10 for 1000 bps)
- has_fees(), has_rewards(): Quick checks
- qualifies_for_rewards(size, spread_bps): Check maker rebate eligibility
- rewards_min_size(), rewards_max_spread_bps(): Access reward constraints
- seconds_remaining(), is_expired(), is_active(): Window timing
- calculate_fee(size, price): Compute fee for a trade

Key decisions:
- MarketSession is separate from TrackedMarket (strategy/mod.rs)
- TrackedMarket handles runtime state (books, inventory, toxic warnings)
- MarketSession handles cached API data (fees, rewards)
- Integration point: TrackedMarket can optionally hold MarketSession
- #[allow(clippy::too_many_arguments)] on constructors (all fields needed)

Notes for next tasks:
- p3-1 (TradingConfig) has no dependencies - ready to start
- MarketSession ready for integration with StrategyLoop
- Fee calculation via calculate_fee() for cost basis tracking
